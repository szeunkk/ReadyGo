아래의 조건을 모두 적용하여, 아래의 요구사항을 모두 구현할 것.
구현 결과를 체크리스트로 반환할 것.

==============================================

조건-커서룰) 아래의 커서룰을 적용하여 작업하고, 이 작업이 끝나면 해당 rules 적용 결과를 체크리스트로 반환할 것.
            - @01-common.mdc

==============================================

조건-파일경로)
구현될 Provider 파일 경로: src/commons/providers/presence/presence.provider.tsx
연동될 Zustand store 경로: src/stores/presence.store.ts

==============================================

핵심요구사항) 완성된 컴포넌트를 layout에서 import하여 연결시킬 것.
            - 연결될 경로: src/app/layout.tsx
            - 연결될 순서: <AuthProvider> 내부, <NextThemesProvider /> 보다 위
            - 다른 Provider(AuthProvider 포함)의 코드는 수정하지 말 것
            - 단, layout.tsx에서 Provider 감싸는 “순서 조정/추가”는 허용

==============================================

# 작업 목표
Supabase Realtime Presence를 사용하여 “실제 접속 여부(online/offline)”를 관리하는
PresenceProvider(bootstrap 컴포넌트)를 구현한다.

이 Provider는:
- UI를 렌더링하지 않는다
- 인증/세션 로직을 직접 다루지 않는다
- AuthProvider에서 제공하는 user 정보를 참조만 한다

==============================================

# 공통 전제 (중요)
- 현재 프로젝트의 인증 구조는 “API 기반 세션”이다.
- 클라이언트는 Supabase 세션/토큰을 직접 조회하지 않는다.
- PresenceProvider는 Supabase Auth 상태를 직접 다루면 안 된다.
- 로그인 여부 판단은 useAuth()의 user 존재 여부로만 한다.

==============================================

# 핵심 요구사항

## 1) Provider 기본 구조
1) PresenceProvider는 client component로 구현할 것.
   - 파일 상단에 'use client' 선언 필수
2) UI를 렌더링하지 않는 bootstrap Provider로 구현할 것.
   - return null 또는 <>{children}</> 형태 허용
3) children을 감싸는 Provider 형태로 구현할 것.

## 2) AuthProvider 연동 규칙 (필수)
4) useAuth()를 사용하여 user 정보를 가져올 것.
   - user?.id 만 사용
   - accessToken, 세션 API, 리다이렉트 로직 접근 금지
5) user.id가 존재할 때만 Presence 로직을 실행할 것.
6) user.id가 null로 변경되면(로그아웃) 즉시 cleanup 수행할 것.

## 3) Supabase Realtime Presence 구현 (핵심)
7) Supabase Realtime을 사용하려면 인증된 클라이언트가 필요하다:
   - API 기반 세션 관리 방식이므로, Realtime 채널 생성 전에 인증 토큰이 필요하다
   - 인증된 Supabase 클라이언트 생성 방법:
     a) /api/auth/session API를 호출하여 현재 세션 확인 (필요시)
     b) 또는 기본 supabase 클라이언트(src/lib/supabase/client.ts)를 사용하되,
        Realtime 채널이 인증을 요구하는 경우 API를 통해 토큰을 가져와서
        Authorization 헤더를 포함한 인증된 클라이언트를 생성할 것
   - 참고: src/components/auth/signup/hooks/index.form.hook.tsx의 authenticatedSupabase 생성 패턴 참고
8) 아래 조건으로 Presence 채널을 생성할 것:
   - channel name: 'presence:global'
   - presence key: user.id
   - 인증된 Supabase 클라이언트를 사용하여 채널 생성
9) channel.subscribe() 성공 후(SUBSCRIBED 상태),
   아래 정보를 track 할 것:
   - user_id: user.id
   - joined_at: ISO timestamp
10) presence 이벤트(sync 등) 발생 시:
    - channel.presenceState()를 통해 현재 접속 중인 userId 목록을 계산
    - 해당 목록을 Zustand store에 반영할 것

## 4) Zustand store 요구사항
11) src/stores/presence.store.ts 에 아래 상태/액션을 구현할 것.
    - presenceUserIds: string[]
    - setPresenceUserIds(userIds: string[])
    - isUserPresent(userId: string): boolean (selector 또는 util)
12) store는 "접속 여부 판단"만 담당하며 UI 상태를 포함하지 않는다.

## 5) Cleanup / 안정성 (필수)
13) 컴포넌트 언마운트 또는 user 변경 시:
    - supabase.removeChannel(channel) 또는 unsubscribe 수행
14) 중복 subscribe 방지:
    - 동일 user.id에 대해 채널이 여러 번 생성되지 않도록 guard 처리
15) 에러 발생 시:
    - console.error 로깅
    - 앱 크래시 없이 안전하게 종료

## 6) 절대 금지 사항
16) Supabase Auth API(getSession, onAuthStateChange 등) 직접 사용 금지
    - 단, Realtime 채널 인증을 위해 API를 통해 토큰을 가져오는 것은 허용
17) AuthProvider 내부 로직 수정 금지
18) user_status 테이블 접근 금지
19) 로그인/로그아웃 리다이렉트 로직 구현 금지

==============================================

# 구현 완료 후 체크리스트 (반드시 출력)

## 커서룰 적용 체크리스트
- [ ] @01-common.mdc 규칙이 적용되었는지

## 기능 요구사항 체크리스트
- [ ] PresenceProvider 파일이 지정 경로에 생성되었는지
- [ ] presence.store.ts가 생성/연결되었는지
- [ ] AuthProvider의 user.id에 의존하여 동작하는지
- [ ] Supabase Presence 채널이 user.id 기준으로 track 되는지
- [ ] presenceState 기반 접속자 목록이 store에 반영되는지
- [ ] isUserPresent(userId)로 접속 여부 판단이 가능한지
- [ ] user 변경/로그아웃 시 cleanup이 정상 수행되는지
- [ ] 중복 subscribe 방지 로직이 있는지
- [ ] AuthProvider 및 다른 Provider 코드가 수정되지 않았는지
- [ ] layout.tsx에서 Provider 순서가 요구사항을 만족하는지
