아래의 조건을 모두 적용하여, 아래의 요구사항을 모두 구현할 것.
구현 결과를 체크리스트로 반환할 것.

==============================================

조건-커서룰) 아래의 커서룰을 적용하여 작업하고, 이 작업이 끝나면 해당 rules 적용 결과를 체크리스트로 반환할 것.
            - @01-common.mdc

==============================================

조건-파일경로)
구현될 Provider 파일 경로:
- src/commons/providers/user-status/user-status.provider.tsx

연동될 Zustand store 경로:
- src/stores/user-status.store.ts

==============================================

핵심요구사항) 완성된 컴포넌트를 layout에서 import하여 연결시킬 것.
            - 연결될 경로: src/app/layout.tsx
            - 연결될 순서:
                <AuthProvider>
                  <PresenceProvider>
                    <UserStatusProvider />
                    {children}
                  </PresenceProvider>
                </AuthProvider>
            - <NextThemesProvider /> 보다 위에 위치할 것.
            - 다른 Provider(AuthProvider, PresenceProvider 포함)의 코드는 수정하지 말 것.
            - 단, layout.tsx에서 Provider 감싸는 “순서 조정/추가”는 허용

==============================================

# 작업 목표
유저가 **직접 설정하는 상태(user_status)** 를 Supabase DB와 연동하고,
Realtime(Postgres Changes)을 통해 모든 페이지에서 실시간으로 동기화한다.

또한 PresenceProvider가 제공하는 “실제 접속 여부”와 결합하여
**최종 표시 상태(effective status)** 를 계산한다.

==============================================

# 공통 전제 (중요)
- 인증 구조는 API 기반 세션이다.
- UserStatusProvider는 Supabase Auth API를 직접 사용하지 않는다.
- 로그인 여부 판단은 useAuth()의 user 존재 여부로만 한다.
- Presence 정보는 usePresenceStore 또는 isUserPresent(userId)로만 참조한다.

==============================================

# 핵심 요구사항

## 1) Provider 기본 구조
1) UserStatusProvider는 client component로 구현할 것.
   - 파일 상단에 'use client' 선언 필수
2) UI를 렌더링하지 않는 bootstrap Provider로 구현할 것.
   - return null 형태 허용
3) children을 렌더링하지 않아도 되며, side-effect 전용 컴포넌트로 동작할 것.

## 2) AuthProvider 연동 규칙 (필수)
4) useAuth()를 사용하여 user 정보를 가져올 것.
   - user?.id만 사용
   - accessToken, 세션 API, 리다이렉트 로직 접근 금지
5) user.id가 존재할 때만 아래 로직을 수행할 것.
6) user.id가 null로 변경되면(로그아웃) 모든 Realtime 구독 cleanup 수행할 것.

## 3) 로그인 후 1회: user_status row 시딩 (필수)
7) 로그인 직후 user_status 테이블에 해당 user의 row가 없을 수 있으므로,
   아래 조건으로 **1회 upsert**를 수행할 것:
   - table: user_status
   - values: { user_id: user.id, status: 'online' }
   - onConflict: user_id
   - 인증된 Supabase 클라이언트 필요:
     * API 기반 세션 관리 방식이므로, DB 작업 시 인증 토큰이 필요하다
     * 인증된 Supabase 클라이언트 생성 방법:
       a) /api/auth/session API를 호출하여 현재 세션 확인 (필요시)
       b) 또는 기본 supabase 클라이언트(src/lib/supabase/client.ts)를 사용하되,
          DB 작업이 인증을 요구하는 경우 API를 통해 토큰을 가져와서
          Authorization 헤더를 포함한 인증된 클라이언트를 생성할 것
       c) 참고: src/components/auth/signup/hooks/index.form.hook.tsx의 authenticatedSupabase 생성 패턴 참고
8) 이 로직은 user.id 변경 시 1회만 실행되도록 guard 처리할 것.
9) 이미 row가 존재하는 경우 status를 덮어쓰지 않도록 구현할 것
   (upsert이지만 동일 값일 경우 결과적으로 변화 없음).

## 4) 실시간 반영: Postgres Changes 구독 (핵심)
10) Supabase Realtime postgres_changes를 구독하려면 인증된 클라이언트가 필요하다:
    - API 기반 세션 관리 방식이므로, Realtime 구독 시 인증 토큰이 필요하다
    - 인증된 Supabase 클라이언트 생성 방법:
      a) /api/auth/session API를 호출하여 현재 세션 확인 (필요시)
      b) 또는 기본 supabase 클라이언트(src/lib/supabase/client.ts)를 사용하되,
         Realtime 채널이 인증을 요구하는 경우 API를 통해 토큰을 가져와서
         Authorization 헤더를 포함한 인증된 클라이언트를 생성할 것
      c) 참고: src/components/auth/signup/hooks/index.form.hook.tsx의 authenticatedSupabase 생성 패턴 참고
11) Supabase Realtime postgres_changes를 구독할 것:
    - schema: 'public'
    - table: 'user_status'
    - event: '*'
    - 인증된 Supabase 클라이언트를 사용하여 채널 생성
12) 이벤트 수신 시 payload.new를 기준으로 아래를 수행할 것:
    - payload.new.user_id
    - payload.new.status
13) 수신된 데이터를 Zustand store의 statusByUserId[user_id]에 반영할 것.
14) 만약 변경된 user_id가 내 user.id와 같다면 myStatus도 함께 갱신할 것.
15) 중복 subscribe 방지:
    - user.id 기준으로 channel이 1개만 유지되도록 guard 처리
16) 언마운트 또는 user 변경 시 removeChannel / unsubscribe 수행할 것.

## 5) 수동 상태 변경 API 제공 (필수)
17) Zustand store에 setMyManualStatus(status) 액션을 제공할 것.
18) setMyManualStatus 호출 시:
    - Supabase DB(user_status)에 upsert 수행
    - onConflict: user_id
    - 인증된 Supabase 클라이언트 필요:
      * API 기반 세션 관리 방식이므로, DB 작업 시 인증 토큰이 필요하다
      * 인증된 Supabase 클라이언트 생성 방법은 위 7번 항목 참고
19) optimistic update를 허용하되,
    - 이후 Realtime 이벤트 수신과 충돌하지 않도록 동일 값 비교 guard 포함

## 6) Zustand store 요구사항
20) src/stores/user-status.store.ts에 아래 상태를 구현할 것:
    - myStatus: 'online' | 'away' | 'dnd' | 'offline' | null
    - statusByUserId: Record<string, ManualStatus>
21) 아래 액션을 제공할 것:
    - setMyStatus(status)
    - setUserStatus(userId, status)
    - setMyManualStatus(status)
22) store는 DB/Realtime side-effect를 직접 수행하지 않고,
    Provider에서 전달받은 결과만 반영하도록 역할을 분리할 것.

## 7) 최종 표시 상태 합성 (필수, B안)
23) PresenceProvider의 접속 여부와 수동 상태를 결합한
    “최종 표시 상태” 계산 로직을 구현할 것.

정책(숨김 오프라인 허용):
- isPresent === false → 무조건 'offline'
- isPresent === true AND manualStatus === 'offline' → 'offline'
    - isPresent === true AND manualStatus !== 'offline' → manualStatus
    - manualStatus가 null인 경우 기본값 'online'

24) 위 로직을 selector 또는 util 형태로 제공할 것:
    - 예: getEffectiveStatus(userId): 'online' | 'away' | 'dnd' | 'offline'
25) UI 컴포넌트에서는 이 selector만 사용하면 되도록 설계할 것.

## 8) 절대 금지 사항
26) Supabase Auth API(getSession, onAuthStateChange 등) 직접 사용 금지
    - 단, Realtime 채널 인증을 위해 API를 통해 토큰을 가져오는 것은 허용
27) Presence 채널 직접 생성 금지 (PresenceProvider만 담당)
28) AuthProvider 코드 수정 금지
29) 로그인/로그아웃 리다이렉트 로직 구현 금지

==============================================

# 구현 완료 후 체크리스트 (반드시 출력)

## 커서룰 적용 체크리스트
- [ ] @01-common.mdc 규칙이 적용되었는지

## 기능 요구사항 체크리스트
- [ ] UserStatusProvider 파일이 지정 경로에 생성되었는지
- [ ] user-status.store.ts가 생성/연결되었는지
- [ ] 로그인 후 1회 user_status row 시딩(upsert)이 수행되는지
- [ ] postgres_changes 구독으로 실시간 상태 동기화가 되는지
- [ ] 내 상태 변경 시 DB + store가 정상 반영되는지
- [ ] 다른 유저 상태 변경이 실시간으로 반영되는지
- [ ] Presence 정보와 결합된 최종 표시 상태 계산이 정확한지
- [ ] 숨김 오프라인(B안) 정책이 적용되는지
- [ ] user 변경/로그아웃 시 cleanup이 수행되는지
- [ ] 중복 subscribe 방지 로직이 존재하는지
- [ ] AuthProvider / PresenceProvider 코드가 수정되지 않았는지
- [ ] layout.tsx에서 Provider 순서가 요구사항을 만족하는지
