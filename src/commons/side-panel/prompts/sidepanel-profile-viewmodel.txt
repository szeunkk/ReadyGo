아래의 조건을 모두 적용하여, 아래의 요구사항을 모두 구현할 것.
구현 결과를 체크리스트로 반환할 것.

==============================================

조건-커서룰) 아래의 커서룰을 적용하여 작업하고, 이 작업이 끝나면 해당 rules 적용 결과를 체크리스트로 반환할 것.
	        - 기존 타입/함수 재사용을 최우선으로 한다
	        - 중복 타입 정의 금지
	        - 분기 로직 추가 금지
	        - UI 전용 판단 로직 금지
	        - domain → ViewModel 변환은 단일 진입 함수만 허용
	        - 기존 파이프라인 변경 없이 확장만 허용

==============================================

조건-파일경로) 참고 및 기준 파일 경로는 다음과 같다.
	        - src/viewmodels/profile/toProfileViewModel.ts
	        - src/features/profile/domain/*
	        - src/viewmodels/profile/ProfileViewModel.ts
	        - src/hooks/*
	        - src/commons/side-panel/sidePanel.tsx

==============================================

조건-구현참고) 반드시 참고할 기존 구현 패턴은 다음과 같다.
	        - 내 프로필 조회 시 사용 중인 toProfileViewModel 변환 파이프라인
	        - Core DTO → ProfileViewModel 단방향 변환 구조
	        - Hook 또는 container 레벨에서 ViewModel 변환 수행
	        - UI 컴포넌트는 ViewModel만 전달받는 구조

==============================================

핵심요구사항) 다음 기능을 step-by-step으로 구현하고, 각 항목의 적용 여부를 체크리스트로 반환할 것.
	1.	상대 프로필 조회 흐름에서 toProfileViewModel을 그대로 재사용한다
	2.	내 프로필과 동일한 변환 파이프라인을 유지한다
	3.	ViewModel 타입을 새로 정의하지 않는다
	4.	변환 함수 내부에 분기 로직을 추가하지 않는다
	5.	상대 전용 로직(조건, 플래그, 해석)을 추가하지 않는다
	6.	변환 로직은 Hook 또는 container 레벨에만 위치시킨다
	7.	UI 컴포넌트는 ProfileViewModel만 전달받도록 유지한다

==============================================

조건-Hook 책임)
	        - API 응답으로 받은 ProfileCoreDTO를 toProfileViewModel에 전달한다
	        - 내/상대 여부를 판단하지 않는다
	        - 변환 결과(ViewModel)만 UI에 노출한다

==============================================

조건-UI 책임)
	        - ViewModel 구조에만 의존한다
	        - Core DTO 또는 변환 함수에 직접 접근하지 않는다
	        - 내/상대 분기 UI 로직을 추가하지 않는다

==============================================

구현 완료 후 반환) 아래 체크리스트를 반드시 반환할 것.
	        - toProfileViewModel 재사용
	        - 내 프로필과 동일한 변환 파이프라인 유지
	        - ViewModel 타입 중복 정의 없음
	        - 변환 함수 분기 로직 없음
	        - 상대 전용 로직 없음
	        - 변환 로직이 Hook 또는 container 레벨에만 존재
	        - UI 컴포넌트는 ViewModel만 사용