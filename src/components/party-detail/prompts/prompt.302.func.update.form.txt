아래의 조건을 모두 적용하여, 아래의 요구사항을 모두 구현할 것.
구현 결과를 체크리스트로 반환할 것.

==============================================

조건-커서룰) 아래의 커서룰을 적용하여 작업하고, 이 작업이 끝나면 해당 rules 적용 결과를 체크리스트로 반환할 것.
            - @01-common.mdc
            - @04-func.mdc

==============================================

조건-파일경로) 참고할 TSX  파일경로: src/components/party-detail/index.tsx
조건-파일경로) 참고할 CSS  파일경로: src/components/party-submit/styles.module.css
조건-파일경로) 참고할 HOOK 파일경로: src/components/party-submit/hooks/index.submit.hook.tsx
조건-파일경로) 참고할 HOOK 파일경로: src/components/party-detail/hooks/index.binding.hook.ts
조건-파일경로) 참고할 HOOK 파일경로: src/components/party/hooks/index.link.modal.hook.tsx
조건-파일경로) 구현될 HOOK 파일경로: src/components/party-submit/hooks/index.update.hook.ts
조건-파일경로) 구현될 HOOK 파일경로: src/components/party-detail/hooks/index.link.modal.hook.ts (선택사항, party-detail에서 사용할 모달 열기 hook)
조건-파일경로) 구현될 TEST 파일경로: src/components/party-submit/tests/index.update.hook.spec.ts

==============================================

핵심요구사항) 병렬처리 구현을 위한 작업 방식 조건
            - 다른 채팅에서 개발중인 파일을 수정 및 삭제 하지 말 것.
            - 테스트 충돌을 방지하기 위해, 빌드테스트, 전체테스트를 하지 말 것.

핵심요구사항) 다음의 기능을 playwright 테스트를 활용하여 TDD기반으로 구현하고, 테스트에 통과할 때까지 반복할 것.
            1) 테스트 제외 라이브러리
                - jest
                - @testing-library/react

            2) 테스트 조건
                - timeout은 설정하지 않거나, 500ms 미만으로 설정할 것.
                - 모든 페이지의 로드 식별 조건은 아래를 따를 것.
                    - 페이지 로드 식별 요구사항: 고정식별자 data-testid 대기 방법
                    - 페이지 로드 식별 금지사항: networkidle 대기 방법

            3) 테스트 데이터 조건
                3-1) 데이터
                    - 실제데이터를 사용할 것.
                    - Mock데이터 사용하지 말 것.
                    
                3-2) 성공시나리오
                    - API 모킹하지 말 것.

                3-3) 실패시나리오
                    - API 모킹하지 말 것.

            4) 테스트시나리오(로그인유저)
                1. /party/[id]에 접속하여 페이지 로드 확인
                2. 하단 유저시나리오에 적절한 테스트시나리오를 생성하여 진행
                
            5) 테스트시나리오(권한 검증)
                1. 본인이 생성한 파티 수정 시나리오
                    - 본인이 생성한 파티 상세 페이지에서 수정하기 버튼 클릭
                    - 수정 모달이 정상적으로 열리고 데이터가 로드되는지 확인
                    - 수정 후 정상적으로 반영되는지 확인
                2. 다른 사용자가 생성한 파티 수정 시도 시나리오
                    - 다른 사용자가 생성한 파티 상세 페이지에 접속
                    - 수정하기 버튼 클릭 시도 (버튼이 비활성화되어 있거나, 클릭 시 권한 오류가 발생하는지 확인)
                    - 또는 수정 API 호출 시 403 Forbidden 오류가 발생하는지 확인

핵심요구사항) 다음의 조건에 맞게 파티상세 수정 기능을 step-by-step 으로 구현하고, 적용 결과를 체크리스트로 반환할 것.
            1) 모달조건
                - 파티 수정 모달 컴포넌트 경로: src/components/party-submit/partySubmit.tsx
                - 모달 프로바이더 경로: src/commons/providers/modal/modal.provider.tsx
                - 이미 셋팅되어있는 modal.provider를 사용할 것.
                - 이미 셋팅되어있는 modal.provider를 수정하지 말 것.
                - 공통컴포넌트 모달의 커스텀 모달로 구현할 것.
            
            2) 라이브러리조건
                - 폼: 이미 설치되어있는 react-hook-form, @hookform/resolvers를 사용할 것.
                - 검증: 이미 설치되어있는 zod를 사용할 것.
            
            3) 컴포넌트 분기조건
                - partySubmit.tsx 컴포넌트는 작성/수정 모드를 분기 처리하여 같은 파일에서 관리할 것.
                - 작성 모드: partyId prop이 없을 때 (기존 동작 유지)
                - 수정 모드: partyId prop이 있을 때 (기존 데이터를 폼에 기본값으로 설정)
                - partySubmit.tsx의 Props 인터페이스에 partyId?: number를 추가할 것.
                - 수정 모드일 때는 헤더 제목을 "파티 수정하기"로 변경할 것.
                - 수정 모드일 때는 하단 버튼 텍스트를 "수정하기"로 변경할 것.
                - 수정 모드일 때는 usePartyUpdate hook을 사용하고, 작성 모드일 때는 usePartySubmit hook을 사용할 것.
            
            4) 데이터 바인딩 조건
                - 수정 모드일 때, partyId를 사용하여 /api/party/[id] API를 직접 호출하여 원본 데이터를 조회할 것.
                - usePartyBinding hook은 변환된 데이터를 반환하므로, 수정 모드에서는 원본 API 데이터를 직접 조회해야 함.
                - API 호출 시 인증이 필요함: GET /api/party/[id]는 인증 토큰이 필요하므로, credentials: 'include'를 사용하여 HttpOnly 쿠키를 포함해야 함.
                - useEffect를 사용하여 partyId가 있을 때만 데이터를 조회하고 폼 기본값을 설정할 것.
                    - useEffect의 의존성 배열에 partyId를 포함할 것.
                    - 데이터 조회가 완료되면 form.reset() 또는 setValue()를 사용하여 폼 필드에 기본값을 설정할 것.
                - 조회한 원본 데이터를 partySubmit.tsx의 폼 필드에 기본값으로 설정할 것.
                - 데이터 변환 규칙 (원본 API 데이터 → 폼 기본값):
                    - game_title: 원본 값 그대로 사용
                    - party_title: 원본 값 그대로 사용
                    - start_date: YYYY-MM-DD 형식의 문자열을 dayjs 객체로 변환 (dayjs(dateString) 사용)
                    - start_time: HH:mm:ss 형식을 "오전 hh:mm" 또는 "오후 hh:mm" 형식으로 변환
                        - 변환 로직: usePartyBinding의 formatTime 함수를 참고하여 역변환 로직을 구현할 것.
                        - formatTime은 HH:mm:ss → "오전 hh:mm" 형식으로 변환하므로, 이를 참고하여 동일한 로직으로 구현할 것.
                        - 예시: "14:30:00" → "오후 02:30", "09:00:00" → "오전 09:00"
                    - description: 원본 값 그대로 사용
                    - max_members: 원본 값 그대로 사용
                    - control_level: 원본 한글 값 그대로 사용 (미숙, 반숙, 완숙, 빡숙, 장인)
                    - difficulty: 원본 한글 값 사용 (미정, 유동, 이지, 노멀, 하드, 지옥)
                    - voice_chat: 원본 값 그대로 사용 (null, 'required', 'optional')
                        - 주의: usePartyBinding의 getVoiceChatLabel은 표시용 텍스트로 변환하므로, 폼 기본값에는 원본 API 데이터의 voice_chat 값을 직접 사용할 것.
                    - tags: string[] 배열을 "#태그1#태그2" 형식의 문자열로 변환
                        - 배열이 null이거나 undefined이면 빈 문자열 ''로 처리
                        - 배열이 비어있으면([]) 빈 문자열 ''로 처리
                        - 배열 요소들을 '#'으로 연결 (예: ['태그1', '태그2'] → '#태그1#태그2')
                        - 변환 로직 예시:
                            - null 또는 undefined → ''
                            - [] → ''
                            - ['태그1', '태그2'] → '#태그1#태그2'
                            - ['태그1'] → '#태그1'
                - 에러 처리 조건:
                    - API 호출 실패 시 적절한 에러 처리를 구현할 것.
                    - 응답 상태 코드별 처리:
                        - 401 (Unauthorized): 인증이 필요함. 모달을 표시하여 로그인 페이지로 이동하도록 안내할 것.
                        - 403 (Forbidden): 수정 권한이 없음. 모달을 표시하여 권한이 없음을 안내할 것.
                        - 404 (Not Found): 파티를 찾을 수 없음. 모달을 표시하여 파티가 존재하지 않음을 안내할 것.
                        - 500 (Internal Server Error): 서버 오류. 모달을 표시하여 서버 오류가 발생했음을 안내할 것.
                    - 에러 발생 시 폼을 초기화하지 말고, 에러 모달만 표시할 것.
                    - 에러 모달은 useModal hook을 사용하여 구현할 것.
            
            6) API 조건
                - 수정 API: PATCH /api/party/[id] 사용
                - 수정 성공 시 상세 페이지 데이터를 리프레시하여 수정된 값이 반영되도록 할 것.
                - 리프레시 방법: usePartyBinding hook이 partyId를 의존성으로 사용하므로, partyId가 변경되지 않으면 자동으로 리프레시되지 않음.
                    - 해결 방법 1: window.location.reload()를 사용하여 페이지 전체 리프레시
                    - 해결 방법 2: usePartyBinding hook에 refetch 함수를 추가하고 이를 호출 (권장하지 않음, hook 수정 필요)
                    - 해결 방법 3: 수정 성공 후 router.push()로 같은 페이지로 이동하여 강제 리프레시
                    - 권장: 해결 방법 3 사용 (router.push(getPartyDetailUrl(partyId)))
            
            7) party-detail 수정 버튼 연결 조건
                - party-detail/index.tsx의 수정하기 버튼에 클릭 핸들러를 추가할 것.
                - 클릭 시 모달을 열기 위해 useModal hook을 직접 사용하거나, party/hooks/index.link.modal.hook.tsx를 참고하여 새로운 hook을 만들 것.
                - 모달을 열 때 openModal의 componentProps로 { partyId: data?.id }를 전달할 것.
                - 예시:
                    ```typescript
                    const { openModal } = useModal();
                    const handleEditClick = () => {
                      openModal({
                        component: PartySubmit,
                        componentProps: { partyId: data?.id },
                      });
                    };
                    ```
                - 또는 party/hooks/index.link.modal.hook.tsx를 참고하여 party-detail 전용 hook을 만들 수도 있음.
                - 권한 검증 조건:
                    - 수정하기 버튼은 파티 작성자(creator_id)에게만 표시/활성화할 것.
                    - useAuth hook을 사용하여 현재 로그인한 사용자 정보를 가져올 것.
                    - data?.creator_id와 user?.id를 비교하여 작성자인지 확인할 것.
                    - 작성자가 아닌 경우:
                        - 수정하기 버튼을 비활성화(disabled)하거나 숨김 처리할 것.
                        - 또는 버튼을 클릭해도 모달이 열리지 않도록 처리할 것.
                    - 작성자인 경우에만 버튼을 활성화하고 클릭 핸들러를 연결할 것.
                    - 예시:
                        ```typescript
                        const { user } = useAuth();
                        const canEdit = data?.creator_id === user?.id;
                        
                        <button 
                          className={styles.actionButton} 
                          type="button"
                          disabled={!canEdit}
                          onClick={canEdit ? handleEditClick : undefined}
                          data-testid="party-edit-button"
                        >
                          <Icon name="edit" size={20} className={styles.buttonIcon} />
                          <span className={styles.buttonText}>수정하기</span>
                        </button>
                        ```
                    - 권한 검증은 프론트엔드에서 UI 제어를 위한 것이며, 실제 권한 검증은 API에서 수행됨.
            
            8) zod 스키마 수정 조건
                - difficulty 필드는 API에서 필수 필드이므로, zod 스키마를 수정하지 말 것.
                - difficulty는 항상 한글 값('미정', '유동', '이지', '노멀', '하드', '지옥') 중 하나를 가져야 함.
                - 기존 스키마: z.string().min(1, '난이도를 선택해주세요.')를 유지할 것.
                - "미정"은 유효한 값이므로, undefined로 처리하지 말고 그대로 사용할 것.
            
            9) 유저시나리오(파티 수정하기)
                1. 파티상세(/party/[id])에서 수정하기 버튼을 클릭
                2. partySubmit.tsx 모달이 열리고, 기존 파티 데이터가 폼에 기본값으로 채워져 있음을 확인
                3. 수정 모드임을 확인 (헤더 제목: "파티 수정하기", 버튼 텍스트: "수정하기")
                4. 폼의 필드들을 수정 (game_title, party_title, start_date, start_time, description, max_members, control_level, difficulty, voice_chat, tags 등)
                5. 수정하기 버튼을 클릭
                6. 수정이 완료되고, 모달이 닫힌 후 상세 페이지가 리프레시되어 수정된 값이 반영되었음을 확인
