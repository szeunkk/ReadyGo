아래의 조건을 모두 적용하여, 아래의 요구사항을 모두 구현할 것.
구현 결과를 체크리스트로 반환할 것.

==============================================

조건-커서룰) 아래의 커서룰을 적용하여 작업하고, 이 작업이 끝나면 해당 rules 적용 결과를 체크리스트로 반환할 것.
            - @01-common.mdc
            - @04-func.mdc

==============================================

조건-파일경로) 참고할 TSX  파일경로: src/components/party-detail/index.tsx
조건-파일경로) 참고할 CSS  파일경로: src/components/party-detail/styles.module.css
조건-파일경로) 구현될 HOOK 파일경로: src/components/party-detail/hooks/index.binding.hook.ts
조건-파일경로) 구현될 TEST 파일경로: src/components/party-detail/tests/index.binding.hook.spec.ts

==============================================

핵심요구사항) 다음의 기능을 playwright 테스트를 활용하여 TDD기반으로 구현하고, 테스트에 통과할 때까지 반복할 것.
            1) 테스트 제외 라이브러리
                - jest
                - @testing-library/react

            2) 테스트 조건
                - timeout은 설정하지 않거나, 500ms 미만으로 설정할 것.
                - /party/[id] 페이지가 완전히 로드된 후 테스트할 것.
                    - 페이지 로드 식별 요구사항: 고정식별자 data-testid 대기 방법
                    - 페이지 로드 식별 금지사항: networkidle 대기 방법

            3) 테스트 데이터 조건
                3-1) 데이터
                    - Supabase 실제데이터를 사용할 것.
                    - Mock데이터 사용하지 말 것.
                    - party_posts 테이블에서 데이터를 조회할 것.

                3-2) 성공시나리오
                    - Supabase에 실제로 존재하는 party_posts의 id를 사용할 것.

                3-3) 실패시나리오
                    - 존재하지 않는 id를 사용하여 에러 처리를 테스트할 것.

            4) 테스트 데이터타입
                - 저장소: Supabase party_posts 테이블
                - 테이블: party_posts
                - 조회 필드: {
                    id: number,
                    party_title: string,
                    game_title: string,
                    description: string,
                    start_date: string,
                    start_time: string,
                    max_members: number,
                    control_level: string,
                    difficulty: string,
                    voice_chat: string | null,
                    tags: Json | null,
                    created_at: string,
                    creator_id: string
                }

핵심요구사항) 다이나믹라우팅된 파티상세페이지의 [Id]를 추출하여 Mock데이터를 제거하고, 실제 데이터를 바인딩할 것.
            1) 바인딩할 데이터
                - Next.js의 useParams를 사용하여 /party/[Id] 경로에서 id를 추출할 것.
                - API Route를 통해 Supabase의 party_posts 테이블에서 추출한 id와 일치하는 파티모집글 상세객체를 조회할 것.
            
            2) API Route를 통한 데이터 조회 방법
                - 클라이언트에서 직접 Supabase 클라이언트를 생성하지 말 것.
                - API Route: GET /api/party/[id]를 사용하여 데이터를 조회할 것.
                - @src/app/api/party/[id]/route.ts를 참고할 것.
                
                2-1) API Route 구현 (이미 존재하는 경우 확인 후 사용)
                    - 파일 경로: src/app/api/party/[id]/route.ts
                    - Supabase SSR 클라이언트 사용:
                        import { createClient } from '@/lib/supabase/server';
                        const supabase = createClient();
                    - 데이터 조회 패턴:
                        const { data: partyData, error: fetchError } = await supabase
                          .from('party_posts')
                          .select('*')
                          .eq('id', id)
                          .single();
                    - 에러 처리 및 응답 반환
                
                2-2) 클라이언트 Hook에서 API 호출
                    - 구현 위치: @src/components/party-detail/hooks/index.binding.hook.ts
                    - fetch API를 사용하여 API Route 호출:
                        const response = await fetch(`/api/party/${id}`, {
                          method: 'GET',
                          credentials: 'include', // HttpOnly 쿠키 포함 (중요!)
                        });
                    - 응답 처리:
                        - 401: 인증 오류
                        - 404: 파티를 찾을 수 없음
                        - 200: 성공, data 필드에 파티 데이터 포함
                    - 에러 처리:
                        if (!response.ok) {
                          // 상태 코드에 따른 에러 처리
                          throw new Error('에러 메시지');
                        }
                    - 데이터 파싱:
                        const { data: partyData } = await response.json();
                
                2-3) 참고사항
                    - 클라이언트에서 직접 Supabase 클라이언트를 생성하는 방식은 사용하지 말 것.
                    - 모든 데이터 조회는 API Route를 통해 수행할 것.
                    - API Route에서는 Supabase SSR 클라이언트(@/lib/supabase/server)를 사용할 것.
                    - credentials: 'include'를 사용하여 HttpOnly 쿠키가 포함되도록 할 것.
            
            3) 상세내용
                - 제목: 파티모집글 상세객체의 party_title
                - 게임제목: 파티모집글 상세객체의 game_title
                - 설명: 파티모집글 상세객체의 description
                - 시작날짜: 파티모집글 상세객체의 start_date
                    - 형식 변환: YYYY-MM-DD 형식의 start_date를 mm/dd 형식으로 변환할 것.
                    - 예시: "2024-12-25" → "12/25"
                    - 년도는 제외하고 월/일만 표시할 것.
                - 시작시간: 파티모집글 상세객체의 start_time
                    - 형식 변환: HH:mm:ss 형식의 start_time을 "오전 hh:mm" 또는 "오후 hh:mm" 형식으로 변환할 것.
                    - 예시: "14:30:00" → "오후 02:30", "09:15:00" → "오전 09:15"
                    - 12시간 형식으로 변환하고 오전/오후를 표시할 것.
                    - @src/components/party-submit/hooks/index.submit.hook.tsx의 convertTimeToSupabaseFormat 함수를 참고하여 역변환 로직을 구현할 것.
                - 최대인원: 파티모집글 상세객체의 max_members
                - 컨트롤수준: 파티모집글 상세객체의 control_level
                    - 한국어 value 값 사용: @src/components/party-submit/PartySubmit.tsx의 controlLevelOptions를 참고하여 id와 매칭되는 한국어 value를 표시할 것.
                    - controlLevelOptions: [
                        { id: 'beginner', value: '미숙' },
                        { id: 'intermediate', value: '반숙' },
                        { id: 'advanced', value: '완숙' },
                        { id: 'expert', value: '빡숙' },
                        { id: 'master', value: '장인' }
                      ]
                - 난이도: 파티모집글 상세객체의 difficulty
                    - 한국어 value 값 사용: @src/components/party-submit/PartySubmit.tsx의 difficultyOptions를 참고하여 id와 매칭되는 한국어 value를 표시할 것.
                    - difficultyOptions: [
                        { id: 'undefined', value: '미정' },
                        { id: 'flexible', value: '유동' },
                        { id: 'easy', value: '이지' },
                        { id: 'normal', value: '노멀' },
                        { id: 'hard', value: '하드' },
                        { id: 'hell', value: '지옥' }
                      ]
                - 보이스채팅: 파티모집글 상세객체의 voice_chat
                    - null 처리: voice_chat이 null이면 "사용 안함"으로 렌더링할 것.
                    - null이 아닌 경우: 해당 값('required' 또는 'optional')을 그대로 표시할 것.
                - 태그: 파티모집글 상세객체의 tags
                    - 저장 형식: tags는 jsonb 컬럼에 string[] 형태로 저장되어 있음
                        - 등록 시 변환: "#금요일#가보자#빡겜" 형식이 "#" 기호로 분리되어 ["금요일", "가보자", "빡겜"] 형태로 저장됨
                        - 조회 시: Supabase에서 조회한 tags는 이미 string[] 배열 형태로 반환됨
                    - 배열 처리:
                        - tags가 null이면 빈 배열([])로 처리할 것.
                        - tags가 배열이면 그대로 사용할 것.
                    - 순서 유지 및 렌더링:
                        - 배열의 순서를 그대로 유지하여 태그 컴포넌트에 전달할 것.
                        - 배열의 각 요소를 순서대로 태그 컴포넌트에 전달하여 나열할 것.
                        - 예시: ["금요일", "가보자", "빡겜"] → 태그 컴포넌트에 순서대로 "금요일", "가보자", "빡겜"이 나열됨
                - 생성일: 파티모집글 상세객체의 created_at
                - 생성자ID: 파티모집글 상세객체의 creator_id

핵심요구사항) 파티 상세 페이지의 버튼 렌더링 로직을 구현할 것.
            1) 참여 상태 확인
                - party_members 테이블에서 현재 사용자가 해당 파티에 참여했는지 확인할 것.
                - API Route를 통해 참여 상태를 조회할 것 (직접 Supabase 클라이언트 생성하지 말 것).
                - API Route 옵션:
                    - GET /api/party/[id]/members?check=true 또는
                    - 별도 API: GET /api/party/[id]/members/check 또는
                    - 기존 GET /api/party/[id] 응답에 isParticipant 필드 추가
                - API Route 구현 시 Supabase SSR 클라이언트 사용:
                    - import { createClient } from '@/lib/supabase/server';
                    - const supabase = createClient();
                    - 조회 패턴:
                        const { data: memberData } = await supabase
                          .from('party_members')
                          .select('id')
                          .eq('post_id', partyId)
                          .eq('user_id', currentUserId)
                          .single();
                - 참여 여부: memberData가 존재하면 참여한 상태, null이면 미참여 상태
                - 클라이언트에서는 fetch API를 사용하여 API Route 호출:
                    - credentials: 'include'를 사용하여 HttpOnly 쿠키 포함

            2) 버튼 렌더링 조건
                2-1) 파티장인 경우 (creator_id === user.id)
                    - 버튼 텍스트: "게임시작"
                    - 아이콘: "play_circle" (Icon 컴포넌트 사용)
                    - 버튼 스타일: 피그마 디자인에 따라 구현
                        - 피그마 링크: https://www.figma.com/design/XCfazIyDI3zOloIscGe6u2/ReadyGo?node-id=2590-73701&m=dev
                        - 버튼 배경색: var(--color/bg/interactive/primary, #56e5ce)
                        - 텍스트 색상: var(--color/text/interactive/inverse, white)
                        - 아이콘과 텍스트 사이 간격: 8px
                        - 아이콘 크기: 20px
                    - 클릭 동작: 게임 시작 기능 (현재는 빈 함수 또는 미구현 상태로 둘 것)

                2-2) 참여자가 아닌 경우 (creator_id !== user.id && memberData === null)
                    - 버튼 텍스트: "참여하기"
                    - 아이콘: 없음
                    - 클릭 동작: 참여하기 기능 실행
                        - @src/components/party-detail/hooks/index.join.hook.ts의 joinParty 함수 사용
                        - 참여 성공 시 참여 상태를 업데이트하여 "파티 나가기" 버튼으로 변경

                2-3) 참여한 경우 (creator_id !== user.id && memberData !== null)
                    - 버튼 텍스트: "파티 나가기"
                    - 아이콘: 없음
                    - 클릭 동작: 파티 나가기 기능 실행
                        - API Route: DELETE /api/party/[id]/members
                        - party_members 테이블에서 해당 레코드 삭제
                        - 삭제 성공 시 참여 상태를 업데이트하여 "참여하기" 버튼으로 변경

            3) 구현 위치
                - @src/components/party-detail/ui/party-info/partyInfo.tsx에서 버튼 렌더링 로직 구현
                - props로 다음 정보를 전달받을 것:
                    - isCreator: boolean (파티장 여부)
                    - isParticipant: boolean (참여자 여부)
                    - onJoinClick: () => void (참여하기 클릭 핸들러)
                    - onLeaveClick: () => void (파티 나가기 클릭 핸들러)
                    - onStartGameClick: () => void (게임시작 클릭 핸들러, 파티장인 경우)

            4) 참여 상태 조회 로직 구현
                - 구현 위치: @src/components/party-detail/hooks/index.binding.hook.ts
                - usePartyBinding hook에 isParticipant 상태 추가
                - API Route를 통해 참여 상태 조회:
                    - GET /api/party/[id]/members?check=true 또는
                    - 별도 API: GET /api/party/[id]/members/check
                    - 또는 기존 GET /api/party/[id] 응답에 isParticipant 필드 추가
                - API Route 구현 시 Supabase SSR 클라이언트 사용:
                    - import { createClient } from '@/lib/supabase/server';
                    - const supabase = createClient();
                    - party_members 테이블에서 post_id와 user_id로 조회:
                        const { data: memberData } = await supabase
                          .from('party_members')
                          .select('id')
                          .eq('post_id', partyId)
                          .eq('user_id', currentUserId)
                          .single();
                    - isParticipant = memberData !== null && memberData !== undefined
                - 클라이언트에서는 API Route를 통해 참여 상태를 조회할 것:
                    - 직접 Supabase 클라이언트를 생성하지 말 것.
                    - fetch API를 사용하여 API Route 호출
                    - credentials: 'include'를 사용하여 HttpOnly 쿠키 포함
                - 반환 타입에 isParticipant 추가:
                    interface UsePartyBindingReturn {
                      data: PartyDetailData | null;
                      isLoading: boolean;
                      error: Error | null;
                      isParticipant: boolean;
                      refetch: () => Promise<void>;
                    }
                - 참여 상태는 파티 데이터 조회 후 또는 동시에 조회할 것.

            5) PartyInfo 컴포넌트에 props 전달
                - 구현 위치: @src/components/party-detail/index.tsx
                - usePartyBinding에서 반환된 isParticipant 사용
                - isCreator 계산: data?.creator_id === user?.id
                - PartyInfo에 다음 props 전달:
                    - isCreator: boolean
                    - isParticipant: boolean
                    - onJoinClick: () => void (기존 handleJoinClick)
                    - onLeaveClick: () => void (새로 구현할 handleLeaveClick)
                    - onStartGameClick: () => void (새로 구현할 handleStartGameClick)
                - 예시:
                    <PartyInfo
                      data={data}
                      isLoading={isLoading}
                      error={error}
                      isCreator={isCreator}
                      isParticipant={isParticipant}
                      onJoinClick={handleJoinClick}
                      onLeaveClick={handleLeaveClick}
                      onStartGameClick={handleStartGameClick}
                    />

            6) PartyInfo 컴포넌트 버튼 조건부 렌더링 구현
                - 구현 위치: @src/components/party-detail/ui/party-info/partyInfo.tsx
                - PartyInfoProps 인터페이스에 다음 props 추가:
                    - isCreator?: boolean;
                    - isParticipant?: boolean;
                    - onJoinClick?: () => void;
                    - onLeaveClick?: () => void;
                    - onStartGameClick?: () => void;
                - 버튼 렌더링 로직:
                    - isCreator가 true인 경우:
                        - 버튼 텍스트: "게임시작"
                        - 아이콘: Icon name="play_circle" size={20}
                        - onClick: onStartGameClick
                        - 버튼 스타일: 피그마 디자인에 맞게 구현
                            - 배경색: #56e5ce (primary 색상)
                            - 텍스트 색상: white
                            - 아이콘과 텍스트 사이 gap: 8px
                    - isParticipant가 false인 경우 (참여자가 아닌 경우):
                        - 버튼 텍스트: "참여하기"
                        - 아이콘: 없음
                        - onClick: onJoinClick
                    - isParticipant가 true인 경우 (참여한 경우):
                        - 버튼 텍스트: "파티 나가기"
                        - 아이콘: 없음
                        - onClick: onLeaveClick
                - 로딩 및 에러 상태에서도 버튼은 disabled 상태로 유지

          

            8) 파티 나가기 핸들러 구현
                - 구현 위치: @src/components/party-detail/hooks/index.leave.hook.ts (새 파일 생성)
                - useLeaveParty hook 생성:
                    - @src/components/party-detail/hooks/index.join.hook.ts를 참고하여 구현
                    - API 호출: DELETE /api/party/[id]/members
                    - API Route는 이미 존재하며 Supabase SSR 클라이언트를 사용함 (@src/app/api/party/[id]/members/route.ts)
                    - 클라이언트에서는 fetch API를 사용하여 API Route 호출:
                        const response = await fetch(`/api/party/${partyId}/members`, {
                          method: 'DELETE',
                          credentials: 'include', // HttpOnly 쿠키 포함 (중요!)
                        });
                    - 성공 시 onRefetch 호출하여 참여 상태 업데이트
                    - 에러 발생 시 모달로 에러 메시지 표시
                - 구현 패턴:
                    interface UseLeavePartyOptions {
                      onRefetch?: () => Promise<void>;
                    }
                    
                    interface UseLeavePartyReturn {
                      leaveParty: (partyId: number | string) => Promise<void>;
                    }
                    
                    export const useLeaveParty = (
                      options?: UseLeavePartyOptions
                    ): UseLeavePartyReturn => {
                      const { openModal } = useModal();
                      const onRefetch = options?.onRefetch;
                      
                      const leaveParty = useCallback(
                        async (partyId: number | string) => {
                          // DELETE API 호출 (fetch 사용)
                          // credentials: 'include' 사용
                          // 성공 시 onRefetch 호출
                          // 실패 시 모달 표시
                        },
                        [openModal, onRefetch]
                      );
                      
                      return { leaveParty };
                    };
                - @src/components/party-detail/index.tsx에서 사용:
                    - import { useLeaveParty } from './hooks/index.leave.hook';
                    - const { leaveParty } = useLeaveParty({ onRefetch: refetch });
                    - handleLeaveClick 함수 구현:
                        const handleLeaveClick = async () => {
                          if (partyId) {
                            try {
                              await leaveParty(partyId);
                              // 참여 상태가 업데이트되면 자동으로 버튼이 변경됨
                            } catch {
                              // 에러는 leaveParty 내부에서 모달로 처리
                            }
                          }
                        };
                - handleStartGameClick 함수 구현 (임시):
                    const handleStartGameClick = () => {
                      // 게임 시작 기능은 추후 구현
                      // 현재는 빈 함수 또는 콘솔 로그
                      console.log('게임 시작');
                    };

