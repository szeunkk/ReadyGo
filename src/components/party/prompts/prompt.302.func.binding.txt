아래의 조건을 모두 적용하여, 아래의 요구사항을 모두 구현할 것.
구현 결과를 체크리스트로 반환할 것.

==============================================

조건-커서룰) 아래의 커서룰을 적용하여 작업하고, 이 작업이 끝나면 해당 rules 적용 결과를 체크리스트로 반환할 것.
            - @01-common.mdc
            - @04-func.mdc

==============================================

조건-파일경로) 참고할 TSX  파일경로: src/components/party/party.tsx
조건-파일경로) 참고할 CSS  파일경로: src/components/party/styles.module.css
조건-파일경로) 구현될 HOOK 파일경로: src/components/party/hooks/index.binding.hook.ts
조건-파일경로) 구현될 TEST 파일경로: src/components/party/tests/index.binding.hook.spec.ts

==============================================

핵심요구사항) 다음의 기능을 playwright 테스트를 활용하여 TDD기반으로 구현하고, 테스트에 통과할 때까지 반복할 것.
            1) 테스트 제외 라이브러리
                - jest
                - @testing-library/react

            2) 테스트 조건
                - timeout은 설정하지 않거나, 500ms 미만으로 설정할 것.
                - /party 페이지가 완전히 로드된 후 테스트할 것.
                    - 페이지 로드 식별 요구사항: 고정식별자 data-testid 대기 방법
                    - 페이지 로드 식별 금지사항: networkidle 대기 방법

            3) 테스트 데이터 조건
                3-1) 데이터
                    - party_posts 테이블: 실제 데이터를 사용할 것.
                    - party_members 테이블: 실제 데이터를 사용할 것.
                    - user_profiles 테이블: 실제 데이터를 사용할 것.

                3-2) 성공시나리오
                    - party_posts 테이블은 실제 Supabase 데이터를 사용할 것.
                    - party_members 테이블은 실제 Supabase 데이터를 사용할 것.
                    - user_profiles 테이블은 실제 Supabase 데이터를 사용할 것.

                3-3) 실패시나리오
                    - party_posts 테이블은 실제 Supabase 데이터를 사용할 것.
                    - party_members 테이블은 실제 Supabase 데이터를 사용할 것.
                    - user_profiles 테이블은 실제 Supabase 데이터를 사용할 것.

핵심요구사항) 현재의 모든 구조를 그대로 유지하고, party_posts, party_members, user_profiles 테이블은 모두 API 기반 실제 데이터를 바인딩할 것.
            1) 데이터조건
                - 데이터 소스: API 라우트를 통한 조회 (party_posts, party_members, user_profiles 모두 실제 데이터)
                - API 엔드포인트: GET /api/party
                - API 라우트 파일 경로: src/app/api/party/route.ts 참고
                - 응답 형식: { data: PartyPost[] } 또는 { error: string }
                - 컬럼 스키마(API 응답 기준으로 사용할 것)
                    - party_posts 테이블 (실제 데이터 사용):
                        - id: bigint (PK)
                        - creator_id: uuid
                        - game_title: text (필수) - 게임명
                        - party_title: text (필수) - 파티 제목
                        - start_date: date (필수) - 시작일
                        - start_time: time (필수) - 시작시간
                        - description: text (필수) - 설명
                        - max_members: int4 (필수) - 최대 인원
                        - control_level: text (필수) - 컨트롤 수준
                        - difficulty: text (필수) - 난이도
                        - voice_chat: text (선택: 'required' | 'optional' | null) - 보이스챗 사용 여부
                        - tags: jsonb (선택: string[] 형태) - 태그
                        - status: text (필수, default: 'recruiting') - 모집 상태
                        - created_at: timestamptz (필수, default: now())
                    - party_members 테이블 (실제 데이터 사용):
                        - post_id: bigint - 파티 ID
                        - user_id: uuid - 참여 유저 ID
                        - role: text - 역할
                        - joined_at: timestamptz - 참여 시각
                        - 참여자 수(currentMembers)는 party_members 테이블에서 같은 post_id의 row 개수로 계산할 것.
                    - user_profiles 테이블 (실제 데이터 사용):
                        - user_id: uuid
                        - animal_type: text - 동물 아바타 타입 (AnimalType enum 값: 'wolf', 'tiger', 'hawk', 'owl', 'fox', 'hedgehog', 'raven', 'bear', 'deer', 'koala', 'dog', 'dolphin', 'panda', 'rabbit', 'leopard', 'cat')

            2) 인증/권한 조건
                - API는 쿠키의 'sb-access-token'을 통해 인증을 처리한다.
                - 인증되지 않은 유저도 파티 목록 조회가 가능해야 하므로, API가 인증 토큰이 없어도 조회 가능하도록 구현되어 있어야 한다.
                - 클라이언트에서는 인증 상태 확인이 필요한 경우: src/commons/providers/auth/auth.provider.tsx의 useAuth() 훅 사용
                - 테스트에서는 mock auth 금지. 실제 개발 환경의 로그인 흐름을 이용할 것(프로젝트 기존 로그인 방식을 따를 것).

            3) 데이터 조회 조건
                3-1) API 호출
                    - GET /api/party?status=recruiting 엔드포인트를 호출할 것.
                    - 쿼리 파라미터: status='recruiting' (모집 중인 파티만 표시).
                    - API 응답은 created_at 기준 내림차순 정렬된 데이터를 반환한다 (최신순).
                    - API 응답은 party_posts 테이블의 데이터만 포함하며, party_members 조인 정보는 포함하지 않는다.
                    - party_members 및 user_profiles 데이터는 별도 API 호출을 통해 실제 데이터를 조회할 것.
                        - party_members 조회: 각 party_posts.id에 대해 GET /api/party/[id]/members 또는 Supabase 클라이언트를 통해 조회
                        - user_profiles 조회: party_members의 user_id 목록을 기반으로 GET /api/profile/[userId] 또는 Supabase 클라이언트를 통해 조회
                        - 또는 API를 수정하여 party_posts 조회 시 party_members와 user_profiles를 함께 조인하여 반환하도록 할 수 있음

                3-2) 데이터 변환
                    - start_date와 start_time을 조합하여 "MM/DD 오전/오후 HH:mm" 형식으로 변환할 것.
                        - 예: start_date="2024-12-25", start_time="18:30:00" → "12/25 오후 6:30"
                        - 예: start_date="2024-12-26", start_time="02:00:00" → "12/26 새벽 2:00"
                    - voice_chat 값을 한글로 변환할 것.
                        - 'required' → "필수 사용"
                        - 'optional' → "선택 사용"
                        - null → "선택 사용" (기본값)
                    - control_level 값을 한글로 변환할 것.
                        - 'beginner' → "미숙"
                        - 'intermediate' → "반숙"
                        - 'advanced' → "완숙"
                        - 'expert' → "빡숙"
                        - 'master' → "장인"
                    - difficulty 값을 한글로 변환할 것.
                        - 'undefined' → "미정"
                        - 'flexible' → "유동"
                        - 'easy' → "이지"
                        - 'normal' → "노멀"
                        - 'hard' → "하드"
                        - 'hell' → "지옥"
                    - memberAvatars를 생성할 것 (실제 데이터 사용).
                        - party_posts의 id를 기반으로 실제 party_members 데이터에서 해당 파티의 참여자 정보를 가져올 것.
                        - party_members의 user_id를 사용하여 실제 user_profiles 데이터에서 animal_type을 조회할 것.
                        - animal_type 값을 아바타 아이콘 파일명과 매칭시킬 것.
                            - animal_type 값과 아바타 아이콘 파일명 매칭 규칙:
                                - 'bear' → 'bear.svg'
                                - 'cat' → 'cat.svg'
                                - 'deer' → 'deer.svg'
                                - 'dog' → 'dog.svg'
                                - 'dolphin' → 'dolphin.svg' 
                                - 'fox' → 'fox.svg'
                                - 'hawk' → 'hawk.svg'
                                - 'hedgehog' → 'hedgehog.svg'
                                - 'koala' → 'koala.svg'
                                - 'leopard' → 'leopard.svg'
                                - 'owl' → 'owl.svg'
                                - 'panda' → 'panda.svg'
                                - 'rabbit' → 'rabbit.svg'
                                - 'raven' → 'raven.svg'
                                - 'tiger' → 'tiger.svg'
                                - 'wolf' → 'wolf.svg'
                        - 참여자 수만큼 동물 아바타를 표시할 것 (최대 4개).
                        - 참여자가 없는 경우 빈 배열로 처리할 것.
                        - user_profiles에서 animal_type이 없는 경우 기본값을 사용할 수 있음.

            4) 구현 방법
                4-1) API 호출
                    - fetch 또는 axios 등을 사용하여 GET /api/party?status=recruiting 호출
                    - 쿠키는 자동으로 포함되므로 별도로 설정할 필요 없음
                    - Content-Type: application/json 헤더 사용
                    - API는 party_posts 테이블의 데이터만 반환하며, party_members나 user_profiles 정보는 포함하지 않음
                    - party_members 데이터 조회: 각 party_posts.id에 대해 Supabase 클라이언트를 사용하여 party_members 테이블에서 post_id로 필터링하여 조회
                        - 예시: supabase.from('party_members').select('*').eq('post_id', postId)
                    - user_profiles 데이터 조회: party_members의 user_id 목록을 기반으로 Supabase 클라이언트를 사용하여 user_profiles 테이블에서 조회
                        - 예시: supabase.from('user_profiles').select('user_id, animal_type').in('user_id', userIds)
                
                4-2) 데이터 조회 및 변환
                    - party_posts 목록을 조회한 후, 각 파티에 대해 party_members를 조회할 것.
                    - party_members 조회 결과에서 user_id 목록을 추출하고, 해당 user_id들로 user_profiles를 조회할 것.
                    - user_profiles 조회 결과를 user_id를 키로 하는 Map 또는 객체로 변환하여 빠른 조회가 가능하도록 할 것.
                
                4-3) 데이터 변환 및 바인딩
                    - API 응답의 data 배열을 순회하며 각 파티 데이터를 변환할 것.
                    - title: party_posts.party_title (실제 데이터)
                    - description: party_posts.description (실제 데이터) => 카드 사이즈를 넘어가는 경우, "..."으로 표현하여 카드 사이즈를 넘어가지 않도록 할 것.
                    - gameTag: party_posts.game_title (실제 데이터)
                    - memberAvatars: 실제 party_members 데이터에서 해당 post_id의 user_id 목록을 가져오고, 각 user_id에 대응하는 user_profiles의 animal_type을 사용하여 아바타 아이콘 파일명으로 변환 (최대 4개, 실제 데이터 사용)
                        - animal_type 값은 AnimalType enum 값이며, 이를 아바타 아이콘 파일명(예: 'bear.svg')으로 변환하거나, Avatar 컴포넌트에 직접 animal_type 값을 전달할 수 있음
                    - currentMembers: 실제 party_members 데이터에서 해당 post_id의 row 개수 (COUNT, 실제 데이터 사용)
                    - maxMembers: party_posts.max_members (실제 데이터)
                    - categories.startTime: start_date와 start_time을 조합하여 변환한 값 (실제 데이터)
                    - categories.voiceChat: voice_chat 값을 한글로 변환한 값 (실제 데이터)
                    - categories.difficulty: difficulty 값을 한글로 변환한 값 (실제 데이터)
                    - categories.controlLevel: control_level 값을 한글로 변환한 값 (실제 데이터)

            5) 에러 처리
                - API 호출 실패 시: 에러 메시지를 콘솔에 출력하고, 빈 배열을 반환하여 빈 목록을 표시할 것.
                - API 응답이 { error: string } 형식인 경우: 에러 메시지를 콘솔에 출력하고, 빈 배열을 반환할 것.
                - HTTP 상태 코드가 4xx 또는 5xx인 경우: 에러 메시지를 콘솔에 출력하고, 빈 배열을 반환할 것.
                - 네트워크 오류 시: 사용자에게 적절한 피드백을 제공할 것 (선택사항).

            6) 테스트 검증 포인트(Playwright)
                - /party 페이지 로드 후 data-testid="party-page"로 대기
                - 파티 목록이 렌더링되는지 확인
                - 파티 카드의 제목, 설명, 게임 태그가 올바르게 표시되는지 확인
                - 파티 카드의 인원 수(currentMembers/maxMembers)가 올바르게 표시되는지 확인
                - 파티 카드의 카테고리 정보(시작 시간, 보이스챗, 난이도, 컨트롤 수준)가 올바르게 표시되는지 확인
                - 데이터가 없는 경우 빈 목록이 표시되는지 확인
                - 데이터 조회 실패 시 적절한 처리 확인
