아래의 조건을 모두 적용하여, 아래의 요구사항을 모두 구현할 것.
구현 결과를 체크리스트로 반환할 것.

==============================================

조건-커서룰) 아래의 커서룰을 적용하여 작업하고, 이 작업이 끝나면 해당 rules 적용 결과를 체크리스트로 반환할 것.
            - @01-common.mdc
            - @04-func.mdc

==============================================

조건-파일경로) 참고할 TSX  파일경로: src/components/party/party.tsx
조건-파일경로) 참고할 CSS  파일경로: src/components/party/styles.module.css
조건-파일경로) 참고할 HOOK 파일경로: src/components/party/hooks/index.binding.hook.ts
조건-파일경로) 구현될 HOOK 파일경로: src/components/party/hooks/index.infinityScroll.hook.ts
조건-파일경로) 구현될 TEST 파일경로: src/components/party/tests/index.infinityScroll.hook.spec.ts

==============================================

핵심요구사항) 다음의 기능을 playwright 테스트를 활용하여 TDD기반으로 구현하고, 테스트에 통과할 때까지 반복할 것.
            1) 테스트 제외 라이브러리
                - jest
                - @testing-library/react

            2) 테스트 조건
                - timeout은 설정하지 않거나, 500ms 미만으로 설정할 것.
                - /party 페이지가 완전히 로드된 후 일기쓰기버튼을 클릭한 이후 테스트할 것.
                    - 페이지 로드 식별 요구사항: 고정식별자 data-testid 대기 방법
                    - 페이지 로드 식별 금지사항: networkidle 대기 방법

            3) 테스트 API 조건
                3-1) 데이터
                    - 실제데이터를 사용할 것.
                    - Mock데이터 사용하지 말 것.

                3-2) 성공시나리오
                    - API 모킹하지 말 것.
                    - 실제 파티 목록 데이터가 반환되는지 확인할 것.

                3-3) 실패시나리오
                    - API 모킹할 것.

핵심요구사항) 제공된 API 및 기존 코드를 참고하여 파티 목록 무한스크롤 기능을 step-by-step 으로 구현하고, 적용 결과를 체크리스트로 반환할 것.
            1) 라이브러리조건
                - 무한스크롤: 이미 설치되어있는 react-infinite-scroller를 사용할 것.
                - API: fetch API를 사용할 것 (기존 index.binding.hook.ts와 동일한 방식).

            2) API 조건
                2-1) API 엔드포인트: GET /api/party
                2-2) 요청 파라미터
                    - limit: 한 번에 가져올 파티 개수
                        - 초기 로드: 6개 (INITIAL_LIMIT = 6)
                        - 무한스크롤 로드: 10개 (SCROLL_LIMIT = 10)
                    - offset: 시작 위치 (기본값: 0)
                2-3) 응답 데이터: { data: PartyPost[] }
                    - PartyPost 타입은 index.binding.hook.ts의 PartyPost 인터페이스를 참고할 것.

            3) 유저시나리오(파티목록 무한스크롤)
                1. 페이지에 접속하면, 파티 목록조회 API를 요청할 것.
                    1-1) API엔드포인트: GET /api/party?limit=6&offset=0 (초기 렌더링은 6개만 표시)
                    1-2) 요청데이터: 없음
                    1-3) 응답데이터: { data: PartyPost[] }
                    1-4) 초기 렌더링: 카드 6개만 표시하고, 그 이후부터 무한스크롤이 작동하도록 구현할 것.
                
                2. 조회 로딩중에는 로딩 상태를 표시할 것.
                    - 로딩 방식: 기존 party.tsx의 로딩 처리 방식을 참고할 것.
                    - 초기 로딩: "로딩 중..." 메시지 표시
                    - 추가 로딩: 무한스크롤 트리거 시 로딩 인디케이터 표시

                3. 조회에 성공하여 받은 파티 목록을 무한스크롤 형태로 노출할 것.
                    - react-infinite-scroller의 InfiniteScroll 컴포넌트를 사용할 것.
                    - 스크롤 감지: Custom parent element 방식을 사용할 것 (getScrollParent prop을 사용하여 스크롤 가능한 부모 요소를 지정).
                    - 카드 렌더링: 기존 Card 컴포넌트를 사용할 것.
                    - 카드 레이아웃: 카드는 가로로 2개씩 표시되도록 CSS를 설정할 것.
                
                4. 유저가 페이지를 스크롤하면, 추가적인 파티 목록을 요청하여 바인딩 할 것.
                    - 스크롤조건: 스크롤이 마지막 2개 카드만 남겨놓은 상태에서 다음 페이지 로드
                    - 페이지 크기: 초기 로드는 6개, 이후 무한스크롤은 10개씩 로드
                    - API 요청: GET /api/party?limit=10&offset=6 (두 번째 요청부터)
                    - 데이터 누적: 기존 데이터에 새 데이터를 추가하여 누적 표시
                    - 더 이상 데이터가 없을 경우: hasMore 상태로 제어
                    - 더 이상 데이터가 없을 경우 "마지막 게시물입니다" 메시지 표시
                        - 조건: !hasMore && partyList.length > 0 일 때 표시
                        - 메시지는 InfiniteScroll 컴포넌트 내부에 표시할 것
                        - CSS 클래스는 .statusMessage를 사용하여 다른 상태 메시지와 동일한 스타일을 적용할 것

            4) 데이터 변환
                - API 응답 데이터를 PartyCardProps 형태로 변환할 것.
                - 변환 로직은 index.binding.hook.ts의 변환 로직을 재사용할 것.
                    - formatDateTime: 날짜/시간 포맷팅
                    - getVoiceChatLabel: 음성채팅 라벨 변환
                    - getDifficultyLabel: 난이도 라벨 변환
                    - getControlLevelLabel: 조작레벨 라벨 변환
                    - getMemberAvatars: 멤버 아바타 생성 (Mock 데이터 사용)
                    - getCurrentMembers: 현재 멤버 수 계산 (Mock 데이터 사용)
                    - truncateDescription: 설명 텍스트 자르기

            5) 훅 구조
                - useInfinitePartyList 훅을 구현할 것.
                - 반환값:
                    - data: PartyCardProps[] - 누적된 파티 목록 데이터
                    - hasMore: boolean - 더 불러올 데이터가 있는지 여부
                    - loadMore: () => Promise<void> - 다음 페이지 로드 함수
                    - isLoading: boolean - 로딩 중 여부
                    - error: Error | null - 에러 상태
                    - reset: () => void - 데이터 초기화 함수 (선택사항)

            6) 컴포넌트 통합
                - party.tsx에서 useInfinitePartyList 훅을 사용할 것.
                - 스크롤 컨테이너를 생성하고, react-infinite-scroller의 InfiniteScroll 컴포넌트로 mainArea를 감쌀 것.
                - InfiniteScroll 컴포넌트는 getScrollParent prop을 사용하여 스크롤 가능한 부모 요소를 지정할 것.
                - getScrollParent prop은 함수를 전달하여 스크롤 가능한 부모 요소를 반환하도록 구현할 것.
                - 스크롤 컨테이너는 CSS에서 overflow-y: auto 또는 overflow: auto를 설정하여 스크롤 가능하도록 해야 함.
                - 기존 usePartyListBinding 훅은 제거하거나 무한스크롤 훅으로 대체할 것.
                
            7) CSS 조건
                - .mainArea에서 카드가 가로로 2개씩 표시되도록 설정할 것.
                    - 각 카드의 너비를 계산하여 2개가 한 줄에 정확히 배치되도록 설정할 것.
                    - gap을 고려하여 카드 너비를 계산할 것 (예: (1272px - gap) / 2).
                - 스크롤 컨테이너에 overflow-y: auto 또는 overflow: auto를 설정하여 스크롤 가능하도록 할 것.
                - 스크롤 컨테이너의 높이를 적절히 설정하여 스크롤이 동작하도록 할 것.
                - 필요시 styles.module.css에서 스크롤 컨테이너 및 .mainArea 관련 스타일을 수정할 것.