아래의 조건을 모두 적용하여, 아래의 요구사항을 모두 구현할 것.
구현 결과를 체크리스트로 반환할 것.

==============================================

조건-커서룰) 아래의 커서룰을 적용하여 작업하고, 이 작업이 끝나면 해당 rules 적용 결과를 체크리스트로 반환할 것.
            - @01-common.mdc
            - @04-func.mdc

==============================================

조건-파일경로) 수정할 TSX 파일경로: src/components/chat/ui/chat-room/chatRoom.tsx
조건-파일경로) 참고할 Hook 파일경로: src/components/chat/hooks/useChatRoom.hook.tsx
조건-파일경로) 참고할 Repository 파일경로: src/repositories/chat.repository.ts
조건-파일경로) 참고할 Auth Provider: src/commons/providers/auth/auth.provider.tsx

==============================================

핵심요구사항) chatRoom.tsx 컴포넌트에서 Mock 데이터를 제거하고, useChatRoom Hook을 사용하여 실제 데이터를 바인딩할 것.

            1) Hook import 및 사용
                - src/components/chat/hooks/index.ts에서 useChatRoom, useChatList Hook을 import할 것.
                - useAuth Hook을 import하여 현재 사용자 ID를 가져올 것.
                - roomId prop을 number로 변환하여 useChatRoom Hook에 전달할 것.
                    - roomId는 string 타입 (URL 파라미터)이므로 parseInt(roomId, 10)으로 변환
                    - roomId가 없거나 유효하지 않은 경우 0 또는 null 전달
                - useChatRoom Hook을 호출하여 messages, sendMessage, markAsRead, isLoading, error, isConnected를 받을 것.
                - useChatList Hook을 호출하여 chatRooms를 받을 것 (상대방 정보 조회용).

            2) Mock 데이터 제거
                - MOCK_ROOM_DATA, DEFAULT_MOCK_DATA 객체를 모두 제거할 것.
                - MOCK_CURRENT_USER_ID 상수를 제거할 것.
                - ChatMessage, ChatMessageRead 등의 Mock 타입 정의를 제거할 것.
                - mockChatRooms import를 제거할 것.

            3) 메시지 데이터 바인딩
                - useChatRoom Hook이 반환하는 messages 배열을 사용할 것.
                - messages는 Database 타입의 ChatMessage[] 배열임.
                - ChatMessage 타입 구조:
                    - id: number
                    - content: string | null
                    - content_type: string | null
                    - created_at: string | null
                    - sender_id: string | null
                    - room_id: number | null
                    - is_read: boolean | null (선택사항, Hook에서 제공하지 않을 수 있음)
                
                - groupedMessages 생성 로직은 그대로 유지하되, MOCK_MESSAGES 대신 messages 사용
                - 날짜 구분선, 연속 메시지 로직은 그대로 유지

            4) 현재 사용자 ID 확인
                - useAuth() Hook을 사용하여 현재 사용자 ID를 가져올 것.
                - const { user } = useAuth();
                - const currentUserId = user?.id;
                - isOwnMessage 판단 시: message.sender_id === currentUserId

            5) 상대방 정보 조회
                - useChatList Hook을 추가로 호출하여 chatRooms 목록에서 상대방 정보를 가져올 것.
                - useChatList Hook import 및 호출:
                    - import { useChatList } from '@/components/chat/hooks';
                    - const { chatRooms } = useChatList();
                - chatRooms 배열에서 현재 roomId와 일치하는 채팅방 찾기:
                    - const currentRoom = chatRooms.find(room => room.room.id === roomIdNumber);
                - 해당 채팅방의 otherMember 정보 사용:
                    - nickname: currentRoom?.otherMember?.nickname || "알 수 없음"
                    - animalType: currentRoom?.otherMember?.animal_type
                    - user_id: currentRoom?.otherMember?.user_id
                - otherMember가 없는 경우 기본값 사용:
                    - nickname: "알 수 없음"
                    - animalType: undefined
                    - status: 'offline'
                - 장점: 이미 로드된 데이터 재사용, 추가 API 호출 불필요
                - 주의: chatRooms가 아직 로드되지 않은 경우 otherMember가 undefined일 수 있으므로 옵셔널 체이닝 사용

            6) 메시지 전송 기능
                - Input 컴포넌트에 상태 관리 추가:
                    - const [messageInput, setMessageInput] = useState('');
                - Input의 value와 onChange 연결
                - 전송 버튼 클릭 시:
                    - sendMessage(messageInput, 'text') 호출
                    - 전송 성공 시 messageInput 초기화
                    - 전송 실패 시 에러 처리 (에러 메시지 표시 또는 콘솔 로그)
                - Enter 키 입력 시 전송 (선택사항)
                - 차단 상태인 경우 전송 비활성화 (기존 로직 유지)

            7) 읽음 상태 처리
                - useChatRoom Hook이 자동으로 읽음 처리를 수행하므로, 컴포넌트에서는 추가 로직 불필요
                - is_read 필드는 Hook에서 제공하지 않을 수 있으므로, 기본값 false 사용
                - 읽음 표시는 기존 로직 유지 (MOCK_MESSAGE_READS 대신 messages의 is_read 필드 사용)

            8) 차단 상태 처리
                - 현재 Hook에서 차단 상태를 제공하지 않으므로, 별도 API 호출 필요
                - 임시 처리: 기본값 false 사용
                - 추후 API 구현 시 차단 상태를 동적으로 조회하여 표시
                - 차단 배너는 isBlocked 상태에 따라 표시 (기존 로직 유지)

            9) 로딩 상태 처리
                - isLoading이 true인 경우 로딩 UI 표시 (선택사항: 스켈레톤 또는 로딩 메시지)
                - 메시지 리스트 영역에 로딩 표시

            10) 에러 상태 처리
                - error가 null이 아닌 경우 에러 메시지 표시 (선택사항: UI 표시 또는 콘솔 로그)
                - 에러 발생 시에도 기존 UI는 유지하여 앱이 중단되지 않도록 처리

            11) 연결 상태 처리 (선택사항)
                - isConnected 상태를 활용하여 연결 상태 표시 (선택사항)

==============================================

세부요구사항) 메시지 전송 구현 상세

            1) Input 상태 관리
                - useState를 사용하여 messageInput 상태 관리
                - Input 컴포넌트에 value={messageInput}, onChange={(e) => setMessageInput(e.target.value)} 연결

            2) 전송 버튼 클릭 핸들러
                - handleSendMessage 함수 작성:
                    - messageInput이 비어있으면 전송하지 않음
                    - sendMessage(messageInput, 'text') 호출
                    - try-catch로 에러 처리
                    - 전송 성공 시 setMessageInput('')로 초기화
                    - 전송 실패 시 에러 메시지 표시 (선택사항)

            3) Enter 키 입력 처리 (선택사항)
                - Input 컴포넌트에 onKeyDown 핸들러 추가
                - Enter 키 입력 시 handleSendMessage 호출
                - Shift+Enter는 줄바꿈으로 처리 (선택사항)

            4) 전송 중 상태 처리
                - 전송 중에는 버튼 비활성화 (선택사항)
                - useState로 isSending 상태 관리

==============================================

세부요구사항) 상대방 정보 조회

            1) useChatList Hook 활용 (권장 방법)
                - useChatList Hook을 추가로 호출:
                    - import { useChatList } from '@/components/chat/hooks';
                    - const { chatRooms } = useChatList();
                - chatRooms 배열에서 현재 roomId와 일치하는 채팅방 찾기:
                    - const roomIdNumber = parseInt(roomId, 10);
                    - const currentRoom = chatRooms.find(room => room.room.id === roomIdNumber);
                - otherMember 정보 추출:
                    - const otherMember = currentRoom?.otherMember;
                    - nickname: otherMember?.nickname || "알 수 없음"
                    - animalType: otherMember?.animal_type
                    - user_id: otherMember?.user_id
                - 옵셔널 체이닝 사용하여 안전하게 접근
                - chatRooms가 아직 로드되지 않은 경우 기본값 사용
                - 장점: 이미 로드된 데이터 재사용, 추가 API 호출 불필요, 성능 최적화
                - 주의: chatRooms가 빈 배열이거나 해당 roomId가 없는 경우 처리 필요

            2) 기본값 처리
                - otherMember가 없는 경우 기본값 사용:
                    - nickname: "알 수 없음"
                    - animalType: undefined
                    - status: 'offline'
                - useMemo를 사용하여 roomId 변경 시 상대방 정보 재계산

==============================================

세부요구사항) 컴포넌트 구조 유지

            1) 기존 UI 구조 유지
                - 헤더, 메시지 리스트, 입력 영역 구조는 그대로 유지
                - 스타일링은 변경하지 않음
                - 접근성 속성(aria-label 등)은 그대로 유지

            2) 함수 유지
                - formatMessageTime 함수는 그대로 유지
                - formatDateDivider 함수는 그대로 유지
                - isNewDate 함수는 그대로 유지
                - isConsecutiveMessage 함수는 그대로 유지

            3) 상태 관리
                - useSideProfilePanel Hook은 그대로 유지
                - messageInput 상태 추가
                - isSending 상태 추가 (선택사항)

==============================================

세부요구사항) 에러 처리 및 예외 상황

            1) roomId 없음 또는 유효하지 않음
                - roomId가 없거나 NaN인 경우: ChatNull 컴포넌트 표시 또는 에러 메시지
                - useChatRoom Hook에 0 전달 시 빈 메시지 목록 반환

            2) 사용자 인증 없음
                - user?.id가 없는 경우: 로그인 페이지로 리다이렉트 또는 에러 메시지
                - useAuth Hook이 null을 반환하는 경우 처리

            3) 메시지 없음
                - messages.length === 0인 경우: 빈 메시지 UI 표시 (기존 로직 유지)

            4) 로딩 중
                - isLoading === true인 경우: 로딩 UI 표시 (선택사항)

            5) 에러 발생
                - error가 null이 아닌 경우: 콘솔 에러 로그 출력
                - 사용자에게는 기존 UI 유지 (에러 메시지 UI는 선택사항)

            6) 전송 실패
                - sendMessage 호출 실패 시: 에러 메시지 표시 또는 토스트 알림
                - messageInput은 그대로 유지하여 재전송 가능하도록 처리

            7) 상대방 정보 없음
                - otherMember가 없는 경우: 기본값 사용 ("알 수 없음")

==============================================

체크리스트) 구현이 완료되면 다음 항목을 포함한 체크리스트를 반환할 것.
            - [ ] 커서룰 @01-common.mdc 적용 결과
            - [ ] 커서룰 @04-func.mdc 적용 결과
            - [ ] useChatRoom Hook import 및 사용 완료
            - [ ] useChatList Hook import 및 사용 완료 (상대방 정보 조회용)
            - [ ] useAuth Hook import 및 사용 완료
            - [ ] roomId string → number 변환 완료
            - [ ] Mock 데이터 및 타입 정의 제거 완료
            - [ ] messages 배열 바인딩 완료
            - [ ] 현재 사용자 ID로 isOwnMessage 판단 완료
            - [ ] 메시지 전송 기능 구현 완료 (Input 상태, 전송 버튼, 에러 처리)
            - [ ] 상대방 정보 조회 (임시 처리 또는 API 호출) 완료
            - [ ] 차단 상태 처리 (임시 처리 또는 API 호출) 완료
            - [ ] 로딩 상태 처리 완료
            - [ ] 에러 상태 처리 완료
            - [ ] 기존 UI 구조 및 스타일 유지 완료
            - [ ] 접근성 속성 유지 완료
            - [ ] 날짜 구분선, 연속 메시지 로직 유지 완료

==============================================

참고사항) 

            1) useChatRoom Hook은 이미 다음 기능을 자동으로 처리함:
                - 초기 메시지 로드 (API 호출)
                - postgres_changes 구독 (실시간 메시지 수신)
                - useRealtimeChat 통합 (Broadcast 기반 실시간 전송)
                - 읽음 처리 (roomId 변경 시 자동)
                - 중복 메시지 방지

            2) 메시지 전송 플로우:
                - sendMessage 호출 → API로 DB 저장 → Broadcast로 실시간 전송
                - postgres_changes로 INSERT 이벤트 수신 → messages 배열에 자동 추가
                - 중복 방지를 위해 seenMessageIdsRef로 관리

            3) 상대방 정보 및 차단 상태는 현재 Hook에서 제공하지 않으므로,
               추후 API 확장 시 동적으로 조회하여 표시할 수 있도록 구조만 유지.

            4) useChatList Hook을 사용하여 상대방 정보를 가져오는 것이 권장 방법임.
               이미 로드된 chatRooms 데이터를 재사용하므로 추가 API 호출이 불필요하고 성능상 이점이 있음.

            5) 읽음 상태(is_read)는 Hook에서 제공하지 않을 수 있으므로,
               기본값 false를 사용하거나, 별도 API 호출로 조회할 수 있도록 구조만 유지.

