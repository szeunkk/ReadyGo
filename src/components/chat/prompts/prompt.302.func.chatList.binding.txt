아래의 조건을 모두 적용하여, 아래의 요구사항을 모두 구현할 것.
구현 결과를 체크리스트로 반환할 것.

==============================================

조건-커서룰) 아래의 커서룰을 적용하여 작업하고, 이 작업이 끝나면 해당 rules 적용 결과를 체크리스트로 반환할 것.
            - @01-common.mdc
            - @04-func.mdc

==============================================

조건-파일경로) 수정할 TSX 파일경로: src/components/chat/ui/chat-list/chatList.tsx
조건-파일경로) 참고할 Hook 파일경로: src/components/chat/hooks/useChatList.hook.tsx
조건-파일경로) 참고할 Repository 파일경로: src/repositories/chat.repository.ts

==============================================

핵심요구사항) chatList.tsx 컴포넌트에서 Mock 데이터를 제거하고, useChatList Hook을 사용하여 실제 데이터를 바인딩할 것.

            1) Hook import 및 사용
                - src/components/chat/hooks/index.ts에서 useChatList Hook을 import할 것.
                - useChatList Hook을 호출하여 chatRooms, isLoading, error, markRoomAsReadOptimistic을 받을 것.
                - Hook 파라미터는 기본값으로 사용할 것 (autoRefresh: true, refreshInterval: 30000).
                - src/stores/user-status.store.ts에서 getEffectiveStatus 함수를 import할 것 (상대방 status 조회용).

            2) Mock 데이터 제거
                - mockChatRooms 배열 및 관련 Mock 데이터 타입 정의를 모두 제거할 것.
                - ChatListItemData, ChatRoom, ChatRoomMember, ChatMessage 등의 Mock 타입 정의를 제거할 것.
                - export된 mockChatRooms도 제거할 것.
                - 주의: chatRoom.tsx에서 mockChatRooms를 import하고 있으므로, 해당 파일도 함께 수정 필요.
                    - chatRoom.tsx에서 mockChatRooms import 제거
                    - chatRoom.tsx에서 mockChatRooms 사용 부분 제거 또는 대체

            3) 데이터 타입 변환
                - useChatList Hook이 반환하는 ChatRoomListItem 타입을 사용할 것.
                - ChatRoomListItem 타입 구조:
                    - room: ChatRoom (Database 타입, id는 number)
                    - otherMember?: UserProfile (1:1 채팅의 경우 상대방 정보)
                    - lastMessage?: ChatMessage (마지막 메시지)
                    - unreadCount: number (읽지 않은 메시지 수)
                
                - ChatListItem 컴포넌트의 data prop 타입을 ChatRoomListItem으로 변경할 것.
                - room.id (number)를 String()으로 변환하여 라우팅에 사용할 것.
                    - 변환 방법: String(chatRoom.room.id) 또는 chatRoom.room.id.toString()
                    - 라우팅 시: router.push(getChatRoomUrl(String(chatRoom.room.id)))
                - room.type은 string | null 타입이므로 null 체크 필요:
                    - room.type === 'direct' 비교 전 null 체크 또는 기본값 처리
                    - null인 경우 기본값 'direct'로 처리하거나 타입 가드 사용
                - lastMessage를 그대로 사용 (이미 ChatMessage 타입)
                - unreadCount를 그대로 사용

            4) 채팅방 이름 생성
                - getChatRoomName 함수 시그니처를 변경할 것:
                    - 현재: getChatRoomName(room: ChatRoom, members: ChatRoomMember[])
                    - 변경 후: getChatRoomName(room: ChatRoom, otherMember?: UserProfile)
                - 함수 내부 로직 수정:
                    - room.type === 'direct' (1:1): otherMember?.nickname 사용
                    - room.type === 'group' (그룹): "그룹 채팅" 기본값 사용 (room.name 필드는 DB에 없음)
                    - room.type이 null인 경우: 기본값 'direct'로 처리하거나 "알 수 없음" 반환
                    - otherMember가 없는 경우 "알 수 없음" 반환

            5) 상대방 정보 표시
                - 상대방 정보는 otherMember에서 가져올 것:
                    - otherMember는 user_profiles.Row 타입
                    - otherMember.id (uuid)는 user_profiles 테이블의 id 필드와 매칭됨
                    - otherMember.avatar_url: 사용자가 커스텀한 아바타 URL (string | null)
                    - otherMember.animal_type: 동물 타입 (string)
                - 아바타 이미지 선택 로직 (공통 유틸리티 함수 사용):
                    - src/lib/avatar/getAvatarImagePath.ts의 getAvatarImagePath 함수를 import하여 사용할 것.
                    - getAvatarImagePath 함수는 항상 string을 반환하며, 기본값은 bear 아바타 (회원가입 시 기본값).
                    - 아바타 이미지 선택 우선순위:
                        1) otherMember?.avatar_url이 null이 아닌 경우: avatar_url 사용 (사용자가 커스텀한 아바타)
                        2) otherMember?.avatar_url이 null인 경우: animal_type을 사용하여 동물 타입 이미지 가져오기
                        3) 둘 다 없으면 기본값 bear 아바타 사용
                    - 사용 예시:
                        import { getAvatarImagePath } from '@/lib/avatar/getAvatarImagePath';
                        const avatarImagePath = getAvatarImagePath(
                          otherMember?.avatar_url,
                          otherMember?.animal_type
                        );
                - Avatar 컴포넌트 사용 방식:
                    - animalType={otherMember?.animal_type as AnimalType} prop 전달
                    - status는 presence store를 통해 가져올 것:
                        - src/stores/user-status.store.ts에서 getEffectiveStatus 함수 import
                        - otherMember?.id (uuid)로 getEffectiveStatus(otherMember.id) 호출
                        - 주의: user_profiles에는 user_id 필드가 없고 id 필드(uuid)가 있음 (id 필드가 user_id 역할)
                        - 반환된 상태를 Avatar의 status prop에 전달
                        - getEffectiveStatus는 'online' | 'away' | 'dnd' | 'offline'을 반환하고,
                          Avatar의 status 타입도 'online' | 'away' | 'dnd' | 'offline'이므로 타입 변환 불필요
                        - otherMember가 없는 경우 기본값 'offline' 사용
                    - 예시:
                        import { getEffectiveStatus } from '@/stores/user-status.store';
                        import { getAvatarImagePath } from '@/lib/avatar/getAvatarImagePath';
                        const userStatus = otherMember?.id 
                          ? getEffectiveStatus(otherMember.id) 
                          : 'offline';
                        const avatarImagePath = getAvatarImagePath(
                          otherMember?.avatar_url,
                          otherMember?.animal_type
                        );
                        <Avatar
                          animalType={otherMember?.animal_type as AnimalType}
                          status={userStatus}
                          // ... 기타 props
                        />
                - 1:1 채팅이 아닌 경우 (그룹 채팅) 그룹 아바타 표시 로직 추가 (선택사항)

            6) 읽지 않은 메시지 수 표시
                - unreadCount를 그대로 사용하여 Badge 표시
                - unreadCount > 0인 경우에만 Badge 표시
                - unreadCount > 0인 경우 roomName에 unread 스타일 적용

            7) 채팅방 클릭 처리
                - handleClick 함수에서 markRoomAsReadOptimistic(chatRoom.room.id)를 호출하여 낙관적 업데이트 수행
                - 이후 router.push(getChatRoomUrl(String(chatRoom.room.id)))로 라우팅

            8) 로딩 상태 처리
                - isLoading이 true인 경우 로딩 UI 표시 (선택사항: 스켈레톤 또는 로딩 메시지)
                - isLoading이 false이고 chatRooms.length === 0인 경우 빈 상태 UI 표시

            9) 에러 상태 처리
                - error가 null이 아닌 경우 에러 메시지 표시 (선택사항: 콘솔 로그 또는 UI 표시)
                - 에러 발생 시에도 빈 목록을 표시하여 앱이 중단되지 않도록 처리

            10) 차단 상태 처리
                - ChatRoomListItem 타입에 isBlocked 필드가 없으므로 제거할 것.
                - 현재 컴포넌트에서 isBlocked를 사용하는 부분을 모두 제거:
                    - ChatListItem의 data prop에서 isBlocked 제거
                    - isBlocked 관련 스타일링 제거 (styles.blocked 등)
                    - handleClick에서 isBlocked 체크 로직 제거
                - 추후 API에서 차단 상태를 조회하여 표시할 수 있도록 구조만 유지 (현재는 제거)

==============================================

세부요구사항) 타입 변환 상세

            1) ChatRoomListItem → ChatListItemData 변환
                - ChatListItemData 인터페이스는 제거하고, ChatRoomListItem을 직접 사용하거나
                - 변환 함수를 작성하여 호환성 유지 (권장: 직접 사용)
                
            2) room.id 변환
                - getChatRoomUrl 함수는 string | number를 받으므로 String() 변환 사용
                - 라우팅 시: router.push(getChatRoomUrl(String(chatRoom.room.id)))

            3) room.type null 처리
                - room.type은 string | null 타입이므로 null 체크 필수
                - room.type === 'direct' 비교 전 null 체크:
                    - room.type === null인 경우: 기본값 'direct'로 처리하거나 타입 가드 사용
                    - 예시: const roomType = room.type ?? 'direct';
                - 변환 함수 작성 시 null 처리 포함:
                    const getRoomTypeDisplay = (type: string | null): '1:1' | 'group' => {
                      if (type === 'direct') return '1:1';
                      if (type === 'group') return 'group';
                      return '1:1'; // 기본값
                    };

==============================================

세부요구사항) 컴포넌트 구조 유지

            1) 기존 UI 구조 유지
                - ChatListItem 컴포넌트 구조는 그대로 유지
                - 스타일링은 변경하지 않음
                - 접근성 속성(aria-label 등)은 그대로 유지

            2) 함수 유지 및 수정
                - formatMessageTime 함수는 그대로 유지
                - formatMessageContent 함수는 그대로 유지
                - getChatRoomName 함수는 시그니처 변경 및 로직 수정:
                    - 시그니처: getChatRoomName(room: ChatRoom, otherMember?: UserProfile)
                    - room.type null 체크 포함
                    - otherMember 기반으로 채팅방 이름 생성

            3) 상태 관리
                - selectedRoomId 상태는 그대로 유지
                - Hook의 상태(isLoading, error)는 추가로 관리

==============================================

세부요구사항) 에러 처리 및 예외 상황

            1) 데이터 없음
                - chatRooms.length === 0인 경우: 기존 빈 상태 UI 표시

            2) 로딩 중
                - isLoading === true인 경우: 로딩 UI 표시 (선택사항)

            3) 에러 발생
                - error가 null이 아닌 경우: 콘솔 에러 로그 출력
                - 사용자에게는 빈 목록 표시 (에러 메시지 UI는 선택사항)

            4) otherMember 없음
                - 1:1 채팅인데 otherMember가 없는 경우: "알 수 없음" 표시

            5) room.type null 처리
                - room.type이 null인 경우: 기본값 'direct'로 처리하거나 타입 가드 사용
                - getChatRoomName 함수에서 null 체크 필수

            6) roomId 변환 실패
                - room.id가 유효하지 않은 경우: 라우팅하지 않음

            7) lastMessage null 처리
                - lastMessage?.created_at이 null인 경우: formatMessageTime 호출 전 null 체크
                - lastMessage?.content_type이 null인 경우: formatMessageContent에서 기본값 처리
                - lastMessage가 undefined인 경우: "메시지가 없습니다" 표시

==============================================

체크리스트) 구현이 완료되면 다음 항목을 포함한 체크리스트를 반환할 것.
            - [ ] 커서룰 @01-common.mdc 적용 결과
            - [ ] 커서룰 @04-func.mdc 적용 결과
            - [ ] useChatList Hook import 및 사용 완료
            - [ ] Mock 데이터 및 타입 정의 제거 완료
            - [ ] ChatRoomListItem 타입으로 데이터 바인딩 완료
            - [ ] room.id를 String()으로 변환하여 라우팅 완료
            - [ ] room.type null 체크 및 처리 완료
            - [ ] getChatRoomName 함수 시그니처 변경 및 수정 완료
            - [ ] getAvatarImagePath 유틸리티 함수 import 및 사용 완료
            - [ ] otherMember.id (uuid)와 user_profiles 테이블의 id 필드 매칭 확인 완료
            - [ ] 아바타 이미지 선택 로직 구현 완료 (avatar_url > animal_type > bear 기본값)
            - [ ] getEffectiveStatus를 사용하여 presence 기반 status 조회 완료
            - [ ] isBlocked 필드 제거 완료
            - [ ] lastMessage null 체크 완료
            - [ ] markRoomAsReadOptimistic 호출 완료
            - [ ] 로딩 상태 처리 완료
            - [ ] 에러 상태 처리 완료
            - [ ] 기존 UI 구조 및 스타일 유지 완료
            - [ ] 접근성 속성 유지 완료

==============================================

참고사항) 

            1) useChatList Hook은 이미 postgres_changes 구독을 통해 실시간 업데이트를 처리하므로,
               컴포넌트에서는 추가적인 실시간 처리 로직이 필요 없음.

            2) markRoomAsReadOptimistic은 낙관적 업데이트이므로, 실제 읽음 처리는 채팅방 진입 시
               useChatRoom Hook에서 자동으로 처리됨.

            3) 차단 상태(isBlocked)는 ChatRoomListItem 타입에 없으므로 컴포넌트에서 제거됨.
               추후 API 확장 시 ChatRoomListItem 타입에 추가하여 사용할 수 있도록 구조만 유지.

            4) 그룹 채팅의 경우 members 정보가 현재 Hook에서 제공되지 않으므로,
               추후 API 확장 시 ChatRoomListItem 타입에 members 필드를 추가하여 사용할 수 있도록 구조만 유지.

            5) 아바타 이미지 선택 로직:
               - 공통 유틸리티 함수 사용: src/lib/avatar/getAvatarImagePath.ts
               - getAvatarImagePath 함수를 import하여 사용할 것.
               - 함수는 항상 string을 반환하며, 기본값은 bear 아바타 (회원가입 시 기본값).
               - 선택 우선순위:
                 1) otherMember?.avatar_url이 null이 아닌 경우: avatar_url 사용 (사용자가 커스텀한 아바타)
                 2) otherMember?.avatar_url이 null인 경우: animal_type을 사용하여 동물 타입 이미지 가져오기
                 3) 둘 다 없으면 기본값 bear 아바타 사용
               - 사용 예시:
                 import { getAvatarImagePath } from '@/lib/avatar/getAvatarImagePath';
                 const avatarImagePath = getAvatarImagePath(
                   otherMember?.avatar_url,
                   otherMember?.animal_type
                 );
               - 주의: otherMember.id (uuid)는 user_profiles 테이블의 id 필드와 매칭됨.
                 다른 페이지에서도 동일한 유틸리티 함수를 사용하여 user_profiles 데이터로 아바타 이미지를 가져올 수 있음.

            6) 사용자 상태(status)는 presence store를 통해 조회함.
               - getEffectiveStatus(userId) 함수를 사용하여 presence와 user-status를 결합한 최종 상태를 가져옴.
               - getEffectiveStatus는 'online' | 'away' | 'dnd' | 'offline'을 반환함.
               - Avatar 컴포넌트의 status prop은 'online' | 'away' | 'dnd' | 'offline' 타입이므로,
                 getEffectiveStatus의 반환값을 그대로 전달하면 됨 (타입 변환 불필요).
               - otherMember가 없는 경우 기본값 'offline' 사용.

            7) DB 스키마 정리:
               - chat_rooms 테이블: id (number), type (string | null), created_at (string | null)만 존재
               - room_id, room_type, room_name, updated_at 필드는 없음
               - user_profiles 테이블: avatar_url (string | null), animal_type (string) 존재
               - user_profiles에 status 필드는 없음 (기본값 'offline' 사용)


