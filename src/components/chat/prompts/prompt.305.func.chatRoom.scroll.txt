아래의 조건을 모두 적용하여, 아래의 요구사항을 모두 구현할 것.
구현 결과를 체크리스트로 반환할 것.

==============================================

조건-커서룰) 아래의 커서룰을 적용하여 작업하고, 이 작업이 끝나면 해당 rules 적용 결과를 체크리스트로 반환할 것.
            - @01-common.mdc
            - @04-func.mdc

==============================================

조건-파일경로) 수정할 Hook 파일경로: src/components/chat/hooks/useChatRoom.hook.tsx
조건-파일경로) 수정할 컴포넌트 파일경로: src/components/chat/ui/chat-room/chatRoom.tsx
조건-파일경로) 수정할 스타일 파일경로: src/components/chat/ui/chat-room/styles.module.css

==============================================

핵심요구사항) 채팅방 메시지 스크롤 기능을 구현할 것.
            메시지 전송/수신 시 자동으로 최하단으로 스크롤하고,
            안읽은 메시지가 있을 때 채팅방 진입 시 가장 오래된 안읽은 메시지 위치로 스크롤하며,
            상단에 플로팅 버튼으로 "최근 메시지로 이동" 기능을 제공할 것.

            [원칙]
            - Hook(useChatRoom.hook.tsx): 스크롤 관련 함수 및 트리거 상태 관리
            - 컴포넌트(chatRoom.tsx): 스크롤 실행 및 플로팅 버튼 UI
            - 스타일(styles.module.css): 플로팅 버튼 스타일

            1) Hook 확장 (useChatRoom.hook.tsx 수정 필요)
                - 스크롤 관련 함수 추가:
                    - scrollToBottom(containerRef): 최하단으로 스크롤
                    - scrollToUnreadBoundary(containerRef): 안읽은 메시지 경계로 스크롤
                    - getUnreadBoundaryMessageId(): 가장 오래된 안읽은 메시지 ID 찾기
                    - shouldShowScrollToBottomButton(containerRef): 플로팅 버튼 표시 여부 확인
                    - clearScrollTriggers(): 스크롤 트리거 초기화
                - 스크롤 트리거 상태 추가:
                    - shouldScrollToBottom: boolean (최하단 스크롤 트리거)
                    - shouldScrollToUnread: boolean (안읽은 메시지 경계 스크롤 트리거)
                - 메시지 전송 성공 시 shouldScrollToBottom 트리거 설정
                - 새 메시지 수신 시 자동 스크롤 로직:
                    - 자신이 보낸 메시지: 항상 최하단 스크롤
                    - 상대방 메시지: 자동 스크롤이 활성화되어 있으면 최하단 스크롤
                - 초기 메시지 로드 완료 시:
                    - 안읽은 메시지가 있으면 shouldScrollToUnread 트리거 설정
                    - 없으면 shouldScrollToBottom 트리거 설정
                - Hook 반환 타입에 스크롤 관련 함수 및 상태 추가

            2) 컴포넌트 수정 (chatRoom.tsx)
                - 메시지 리스트 컨테이너에 ref 추가
                - useChatRoom Hook에서 스크롤 관련 함수 및 트리거 상태 받기
                - useEffect로 스크롤 트리거 감지 및 스크롤 실행
                - 메시지 요소에 data-message-id 속성 추가 (안읽은 메시지 경계 스크롤용)
                - 플로팅 버튼 컴포넌트 추가
                - 스크롤 이벤트 리스너로 플로팅 버튼 표시/숨김 처리
                - 플로팅 버튼 클릭 시 최하단으로 스크롤

            3) 스타일 수정 (styles.module.css)
                - 플로팅 버튼 스타일 추가 (메시지 리스트 상단 중앙 고정)
                - 메시지 리스트에 position: relative 추가 (플로팅 버튼 배치용)

==============================================

세부요구사항) Hook 확장 구현 상세 (useChatRoom.hook.tsx)

            1) 스크롤 관련 함수 구현
                - scrollToBottom(containerRef):
                    - containerRef.current가 없으면 early return
                    - requestAnimationFrame을 사용하여 DOM 렌더링 완료 후 스크롤
                    - scrollTop을 scrollHeight로 설정하여 최하단으로 이동
                    - shouldAutoScrollRef.current를 true로 설정
                - scrollToUnreadBoundary(containerRef):
                    - getUnreadBoundaryMessageId()로 안읽은 메시지 ID 찾기
                    - 없으면 scrollToBottom 호출
                    - 있으면 DOM에서 해당 메시지 요소 찾기 (data-message-id 속성 사용)
                    - scrollIntoView로 스크롤 (behavior: 'smooth', block: 'start')
                    - 요소를 찾지 못하면 scrollToBottom 호출
                - getUnreadBoundaryMessageId():
                    - formattedMessages를 순회하며 isRead: false인 첫 번째 메시지 찾기
                    - 자신의 메시지는 제외 (isOwnMessage가 false인 것만)
                    - 찾으면 message.id 반환, 없으면 null 반환
                - shouldShowScrollToBottomButton(containerRef):
                    - containerRef.current가 없으면 false 반환
                    - scrollTop + clientHeight < scrollHeight - threshold (threshold: 50px)이면 true
                    - 최하단이 아니면 true 반환
                - clearScrollTriggers():
                    - shouldScrollToBottom과 shouldScrollToUnread를 false로 초기화

            2) 스크롤 트리거 상태 관리
                - shouldScrollToBottom: useState(false)
                - shouldScrollToUnread: useState(false)
                - shouldAutoScrollRef: useRef(true) (자동 스크롤 여부)

            3) 메시지 전송 시 스크롤 트리거
                - sendMessage 함수에서 전송 성공 시:
                    - shouldAutoScrollRef.current = true
                    - setShouldScrollToBottom(true)

            4) 새 메시지 수신 시 스크롤 트리거
                - handleNewMessage 함수에서:
                    - 자신이 보낸 메시지 (message.sender_id === user?.id):
                        - shouldAutoScrollRef.current = true
                        - setShouldScrollToBottom(true)
                    - 상대방 메시지이고 자동 스크롤이 활성화되어 있으면:
                        - setShouldScrollToBottom(true)

            5) 초기 메시지 로드 완료 시 스크롤 트리거
                - loadMessages 함수에서 메시지 로드 완료 후:
                    - 안읽은 메시지 확인 (msg.sender_id !== user?.id && msg.is_read === false)
                    - 있으면 setShouldScrollToUnread(true)
                    - 없으면 setShouldScrollToBottom(true)

            6) Hook 반환 타입 확장
                - UseChatRoomReturn 타입에 다음 필드 추가:
                    - scrollToBottom: (containerRef: React.RefObject<HTMLDivElement>) => void
                    - scrollToUnreadBoundary: (containerRef: React.RefObject<HTMLDivElement>) => void
                    - getUnreadBoundaryMessageId: () => number | null
                    - shouldShowScrollToBottomButton: (containerRef: React.RefObject<HTMLDivElement>) => boolean
                    - shouldScrollToBottom: boolean
                    - shouldScrollToUnread: boolean
                    - clearScrollTriggers: () => void

==============================================

세부요구사항) 컴포넌트 구현 상세 (chatRoom.tsx)

            1) ref 및 Hook 사용
                - 메시지 리스트 컨테이너 ref 추가:
                    - const messageListRef = useRef<HTMLDivElement>(null)
                - useChatRoom Hook에서 스크롤 관련 함수 및 상태 받기:
                    - scrollToBottom, scrollToUnreadBoundary, shouldScrollToBottom, shouldScrollToUnread, clearScrollTriggers, shouldShowScrollToBottomButton
                - 플로팅 버튼 표시 여부 상태 추가:
                    - const [showScrollToBottomButton, setShowScrollToBottomButton] = useState(false)

            2) 스크롤 트리거 처리
                - useEffect로 스크롤 트리거 감지:
                    - shouldScrollToBottom이 true이면 scrollToBottom 호출 후 clearScrollTriggers 호출
                    - shouldScrollToUnread가 true이면 scrollToUnreadBoundary 호출 후 clearScrollTriggers 호출
                - 의존성 배열: [shouldScrollToBottom, shouldScrollToUnread, scrollToBottom, scrollToUnreadBoundary, clearScrollTriggers]

            3) 스크롤 위치 감지
                - handleScroll 함수 작성:
                    - shouldShowScrollToBottomButton(messageListRef)로 표시 여부 확인
                    - setShowScrollToBottomButton으로 상태 업데이트
                - 스크롤 이벤트 리스너 등록:
                    - useEffect에서 messageListRef.current에 scroll 이벤트 리스너 추가
                    - 초기 상태 확인을 위해 handleScroll 호출
                    - cleanup에서 이벤트 리스너 제거
                - 의존성 배열: [handleScroll, formattedMessages.length]

            4) 메시지 요소에 data-message-id 추가
                - 메시지 렌더링 시 각 메시지 요소에 data-message-id={message.id} 속성 추가
                - 안읽은 메시지 경계 스크롤 시 해당 요소를 찾기 위해 필요

            5) 플로팅 버튼 추가
                - 메시지 리스트 영역 내부에 플로팅 버튼 추가
                - showScrollToBottomButton이 true일 때만 표시
                - 버튼 클릭 시 handleScrollToBottomClick 호출
                - handleScrollToBottomClick: scrollToBottom(messageListRef) 호출
                - 아이콘: chevron-down 사용
                - 텍스트: "최근 메시지"

            6) 메시지 리스트 컨테이너에 ref 연결
                - <div className={styles.messageList} ref={messageListRef}>

==============================================

세부요구사항) 스타일 구현 상세 (styles.module.css)

            1) 메시지 리스트 영역 수정
                - .messageList에 position: relative 추가 (플로팅 버튼 배치용)

            2) 플로팅 버튼 스타일 추가
                - .scrollToBottomButton 클래스 추가:
                    - position: absolute
                    - top: 16px
                    - left: 50%
                    - transform: translateX(-50%)
                    - display: flex
                    - align-items: center
                    - justify-content: center
                    - gap: 8px
                    - padding: 10px 20px
                    - background-color: var(--color-bg-primary)
                    - border: 1px solid var(--color-border-secondary)
                    - border-radius: 24px
                    - cursor: pointer
                    - z-index: 10
                    - box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1)
                    - transition: background-color 0.2s, box-shadow 0.2s
                    - 폰트 스타일: body-md-medium 토큰 사용
                    - color: var(--color-text-primary)
                - hover 상태:
                    - background-color: var(--color-bg-interactive-teritiary-hover)
                    - box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15)
                - active 상태:
                    - background-color: var(--color-bg-interactive-teritiary-pressed)
                    - box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1)
                - focus-visible 상태:
                    - outline: 2px solid var(--color-border-focus-ring)
                    - outline-offset: 2px
                - 아이콘 스타일:
                    - color: var(--color-icon-primary)
                    - flex-shrink: 0

==============================================

세부요구사항) 스크롤 로직 상세

            1) 메시지 전송 시 스크롤
                - sendMessage 성공 후 즉시 shouldScrollToBottom 트리거 설정
                - 컴포넌트에서 useEffect로 감지하여 scrollToBottom 실행
                - DOM 렌더링 완료 후 스크롤 (requestAnimationFrame 사용)

            2) 메시지 수신 시 스크롤
                - handleNewMessage에서 메시지 추가 후:
                    - 자신이 보낸 메시지: 항상 최하단 스크롤
                    - 상대방 메시지: 자동 스크롤이 활성화되어 있으면 최하단 스크롤
                - 컴포넌트에서 useEffect로 감지하여 scrollToBottom 실행

            3) 초기 로드 시 스크롤
                - loadMessages 완료 후:
                    - 안읽은 메시지 확인 (is_read: false인 상대방 메시지)
                    - 있으면 가장 오래된 안읽은 메시지 위치로 스크롤
                    - 없으면 최하단으로 스크롤
                - 컴포넌트에서 useEffect로 감지하여 스크롤 실행

            4) 안읽은 메시지 경계 찾기
                - formattedMessages 배열을 순회하며 isRead: false인 첫 번째 메시지 찾기
                - 자신의 메시지는 제외 (isOwnMessage가 false인 것만)
                - 해당 메시지의 message.id를 반환
                - 없으면 null 반환

            5) 플로팅 버튼 표시 로직
                - 스크롤 이벤트 발생 시마다 shouldShowScrollToBottomButton 호출
                - scrollTop + clientHeight < scrollHeight - threshold (50px)이면 표시
                - 최하단에 있으면 숨김

==============================================

세부요구사항) 에러 처리 및 예외 상황

            1) Hook에서 처리할 예외 상황
                - containerRef.current가 null인 경우:
                    - scrollToBottom, scrollToUnreadBoundary, shouldShowScrollToBottomButton에서 early return
                - 안읽은 메시지 요소를 찾지 못한 경우:
                    - scrollToUnreadBoundary에서 scrollToBottom으로 fallback
                - DOM 렌더링이 완료되지 않은 경우:
                    - requestAnimationFrame을 사용하여 다음 프레임에 스크롤 실행

            2) 컴포넌트에서 처리할 예외 상황
                - messageListRef.current가 null인 경우:
                    - 스크롤 이벤트 리스너 등록 전에 null 체크
                    - useEffect cleanup에서 null 체크
                - 스크롤 트리거가 중복 발생하는 경우:
                    - clearScrollTriggers로 트리거 초기화하여 중복 실행 방지

==============================================

체크리스트) 구현이 완료되면 다음 항목을 포함한 체크리스트를 반환할 것.
            - [ ] 커서룰 @01-common.mdc 적용 결과
            - [ ] 커서룰 @04-func.mdc 적용 결과
            - [ ] useChatRoom Hook에 스크롤 관련 함수 추가 완료 (scrollToBottom, scrollToUnreadBoundary, getUnreadBoundaryMessageId, shouldShowScrollToBottomButton, clearScrollTriggers)
            - [ ] useChatRoom Hook에 스크롤 트리거 상태 추가 완료 (shouldScrollToBottom, shouldScrollToUnread)
            - [ ] 메시지 전송 시 스크롤 트리거 설정 완료
            - [ ] 새 메시지 수신 시 스크롤 트리거 설정 완료 (자신/상대방 구분)
            - [ ] 초기 메시지 로드 완료 시 스크롤 트리거 설정 완료 (안읽은 메시지 확인)
            - [ ] Hook 반환 타입에 스크롤 관련 함수 및 상태 추가 완료
            - [ ] chatRoom.tsx에 메시지 리스트 컨테이너 ref 추가 완료
            - [ ] chatRoom.tsx에 스크롤 트리거 감지 및 실행 로직 추가 완료
            - [ ] chatRoom.tsx에 메시지 요소에 data-message-id 속성 추가 완료
            - [ ] chatRoom.tsx에 플로팅 버튼 컴포넌트 추가 완료
            - [ ] chatRoom.tsx에 스크롤 위치 감지 로직 추가 완료
            - [ ] styles.module.css에 플로팅 버튼 스타일 추가 완료
            - [ ] styles.module.css에 메시지 리스트 position: relative 추가 완료
            - [ ] 메시지 전송 시 자동 스크롤 동작 확인 완료
            - [ ] 새 메시지 수신 시 자동 스크롤 동작 확인 완료
            - [ ] 안읽은 메시지가 있을 때 경계로 스크롤 동작 확인 완료
            - [ ] 안읽은 메시지가 없을 때 최하단으로 스크롤 동작 확인 완료
            - [ ] 플로팅 버튼 표시/숨김 동작 확인 완료
            - [ ] 플로팅 버튼 클릭 시 최하단 스크롤 동작 확인 완료

==============================================

참고사항) 

            1) 스크롤 타이밍:
               - DOM 렌더링 완료 후 스크롤해야 하므로 requestAnimationFrame 사용
               - 메시지 추가 후 레이아웃 재계산 대기 필요

            2) 안읽은 메시지 경계 찾기:
               - formattedMessages를 순회하며 isRead: false인 첫 번째 메시지 찾기
               - 자신의 메시지는 제외 (isOwnMessage가 false인 것만)
               - 가장 오래된 안읽은 메시지 = 배열의 첫 번째 안읽은 메시지

            3) 플로팅 버튼 위치:
               - 메시지 리스트 영역 상단 중앙에 고정
               - position: absolute, top: 16px, left: 50%, transform: translateX(-50%)
               - z-index: 10으로 다른 요소 위에 표시

            4) 스크롤 감지:
               - scroll 이벤트 리스너로 스크롤 위치 감지
               - threshold: 50px (50px 이내면 최하단으로 간주)
               - 스크롤 이벤트는 성능에 영향을 줄 수 있으므로 debounce 고려 가능 (선택사항)

            5) 자동 스크롤 비활성화:
               - 사용자가 수동으로 스크롤을 올렸을 때 자동 스크롤 비활성화
               - shouldAutoScrollRef로 관리
               - 자신이 메시지를 보내면 자동 스크롤 다시 활성화

            6) data-message-id 속성:
               - 안읽은 메시지 경계 스크롤 시 해당 메시지 요소를 찾기 위해 필요
               - querySelector로 [data-message-id="${unreadMessageId}"] 선택
               - 모든 메시지 요소에 추가 (자신/상대방 구분 없이)

            7) 스크롤 트리거 초기화:
               - 스크롤 실행 후 clearScrollTriggers 호출하여 중복 실행 방지
               - useEffect에서 트리거 감지 후 즉시 초기화

            8) 아이콘 사용:
               - chevron-down 아이콘 사용 (public/icons/chevron-down.svg)
               - Icon 컴포넌트로 렌더링

            9) 접근성:
               - 플로팅 버튼에 aria-label="최근 메시지로 이동" 추가
               - 키보드 접근성 고려 (focus-visible 스타일)

            10) 성능 최적화:
                - 스크롤 함수는 useCallback으로 메모이제이션
                - 스크롤 트리거 상태는 필요한 경우에만 업데이트
                - 스크롤 이벤트 리스너는 cleanup에서 제거

