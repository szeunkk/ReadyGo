아래의 조건을 모두 적용하여, 아래의 요구사항을 모두 구현할 것.
구현 결과를 체크리스트로 반환할 것.

==============================================

조건-커서룰) 아래의 커서룰을 적용하여 작업하고, 이 작업이 끝나면 해당 rules 적용 결과를 체크리스트로 반환할 것.
            - @01-common.mdc
            - @04-func.mdc

==============================================

조건-파일경로) 수정할 Hook 파일경로: src/components/chat/hooks/useChatRoom.hook.tsx
조건-파일경로) 수정할 컴포넌트 파일경로: src/components/chat/ui/chat-room/chatRoom.tsx
조건-파일경로) 새로 생성할 Hook 파일경로: src/components/chat/hooks/useChatRoomScroll.hook.tsx
조건-파일경로) 새로 생성할 유틸 파일경로: src/lib/chat/messageFormatter.ts
조건-파일경로) 수정할 Export 파일경로: src/components/chat/hooks/index.ts

==============================================

핵심요구사항) useChatRoom.hook.tsx (1146줄)를 관심사별로 분리하여 가독성과 유지보수성을 개선할 것.
            순수 함수는 유틸로, 스크롤 로직은 별도 hook으로 분리하고, chatRoom.tsx의 스크롤 관련 로직도 hook으로 이동할 것.

            [원칙]
            - Hook(useChatRoom.hook.tsx): 메시지 데이터 관리 및 포맷팅 로직에 집중
            - Hook(useChatRoomScroll.hook.tsx): 스크롤 관련 로직 전담
            - 유틸(lib/chat/messageFormatter.ts): 순수 함수들 (재사용성 및 테스트 용이성)
            - 컴포넌트(chatRoom.tsx): UI 렌더링에만 집중

            1) 순수 함수 분리 (lib/chat/messageFormatter.ts 생성)
                - formatMessageTime: 메시지 시간 포맷팅
                - formatDateDivider: 날짜 구분선 포맷팅
                - formatMessageContent: 메시지 내용 포맷팅
                - isNewDate: 날짜 변경 확인
                - isConsecutiveMessage: 연속 메시지 확인
                - isSameTimeGroup: 같은 시간 그룹 확인

            2) 스크롤 로직 분리 (useChatRoomScroll.hook.tsx 생성)
                - scrollToBottom: 최하단 스크롤
                - scrollToUnreadBoundary: 안읽은 메시지 경계로 스크롤
                - shouldShowScrollToBottomButton: 플로팅 버튼 표시 여부
                - getUnreadBoundaryMessageId: 안읽은 메시지 ID 찾기
                - shouldScrollToBottom, shouldScrollToUnread 상태 관리
                - clearScrollTriggers: 스크롤 트리거 초기화
                - triggerScrollToBottom, triggerScrollToUnread: 스크롤 트리거 함수
                - 초기 스크롤 처리 로직 (formattedMessages 기반)

            3) useChatRoom.hook.tsx 리팩토링
                - 순수 함수들을 messageFormatter.ts에서 import
                - 스크롤 관련 로직 제거 (별도 hook으로 분리)
                - 메시지 데이터 관리 및 포맷팅 로직에 집중
                - useChatRoomScroll hook을 내부에서 호출하여 스크롤 기능 제공
                - 기존 API 인터페이스 유지 (하위 호환성)

            4) chatRoom.tsx 리팩토링
                - 스크롤 관련 로직은 useChatRoom hook에서 제공받음
                - UI 렌더링에만 집중

            5) Export 업데이트
                - index.ts에 useChatRoomScroll export 추가

==============================================

세부요구사항) 순수 함수 분리 구현 상세 (lib/chat/messageFormatter.ts)

            1) 파일 위치
                - src/lib/chat/messageFormatter.ts 생성
                - 프로젝트 구조 일관성: lib/avatar/, lib/date/, lib/nickname/ 패턴 따름

            2) 함수 구현
                - formatMessageTime(dateString: string | null): string
                    - 메시지 시간을 "오전/오후 HH:MM" 형식으로 포맷팅
                - formatDateDivider(dateString: string | null): string
                    - 날짜를 "YYYY년 M월 D일 요일" 형식으로 포맷팅
                - formatMessageContent(message: ChatMessage | null): string
                    - 메시지 내용 포맷팅 (이미지, 시스템 메시지 처리)
                - isNewDate(currentDate: string | null, previousDate: string | null): boolean
                    - 날짜가 변경되었는지 확인 (년, 월, 일 비교)
                - isConsecutiveMessage(currentMessage: ChatMessage, previousMessage: ChatMessage | null): boolean
                    - 연속된 메시지인지 확인 (하위 호환성)
                - isSameTimeGroup(currentMessage: ChatMessage, previousMessage: ChatMessage | null): boolean
                    - 같은 시간(시, 분)에 전송된 메시지인지 확인

            3) 타입 정의
                - ChatMessage 타입 import (Database 타입에서)
                - 모든 함수는 순수 함수 (부수 효과 없음)

==============================================

세부요구사항) 스크롤 로직 분리 구현 상세 (useChatRoomScroll.hook.tsx)

            1) Hook 파라미터 타입
                - UseChatRoomScrollProps:
                    - formattedMessages: FormattedMessageItem[]
                    - userId: string | undefined
                    - isLoading: boolean

            2) Hook 반환 타입
                - UseChatRoomScrollReturn:
                    - scrollToBottom: (containerRef: React.RefObject<HTMLDivElement>) => void
                    - scrollToUnreadBoundary: (containerRef: React.RefObject<HTMLDivElement>) => void
                    - getUnreadBoundaryMessageId: () => number | null
                    - shouldShowScrollToBottomButton: (containerRef: React.RefObject<HTMLDivElement>) => boolean
                    - shouldScrollToBottom: boolean
                    - shouldScrollToUnread: boolean
                    - clearScrollTriggers: () => void
                    - triggerScrollToBottom: () => void
                    - triggerScrollToUnread: () => void

            3) 스크롤 함수 구현
                - scrollToBottom: 최하단으로 스크롤 (requestAnimationFrame 사용)
                - scrollToUnreadBoundary: 안읽은 메시지 경계로 스크롤 (unread-divider 요소 우선, fallback으로 메시지 요소)
                - getUnreadBoundaryMessageId: formattedMessages에서 안읽은 메시지 ID 찾기
                - shouldShowScrollToBottomButton: 스크롤이 전체 길이의 50% 이상 올라갔을 때만 표시
                - clearScrollTriggers: 스크롤 트리거 초기화
                - triggerScrollToBottom: 최하단 스크롤 트리거
                - triggerScrollToUnread: 안읽은 메시지 경계 스크롤 트리거

            4) 초기 스크롤 처리
                - formattedMessages가 준비된 후 초기 스크롤 처리
                - 안읽은 메시지가 있으면 triggerScrollToUnread, 없으면 triggerScrollToBottom
                - isInitialLoadRef로 초기 로드 완료 후 한 번만 실행

            5) 상태 관리
                - shouldScrollToBottom: useState(false)
                - shouldScrollToUnread: useState(false)

==============================================

세부요구사항) useChatRoom.hook.tsx 리팩토링 구현 상세

            1) 순수 함수 제거 및 import
                - formatMessageTime, formatDateDivider, formatMessageContent, isNewDate, isConsecutiveMessage, isSameTimeGroup 함수 제거
                - lib/chat/messageFormatter에서 import

            2) 스크롤 로직 제거
                - scrollToBottom, scrollToUnreadBoundary, getUnreadBoundaryMessageId, shouldShowScrollToBottomButton, clearScrollTriggers 함수 제거
                - shouldScrollToBottom, shouldScrollToUnread 상태 제거
                - shouldAutoScrollRef는 스크롤 hook으로 이동하지 않고 유지 (handleNewMessage에서 사용)

            3) useChatRoomScroll hook 통합
                - formattedMessages가 정의된 후에 useChatRoomScroll 호출
                - scrollHook의 반환값을 useChatRoom의 반환값에 전달 (기존 API 유지)
                - triggerScrollToBottomRef를 사용하여 handleNewMessage와 sendMessage에서 스크롤 트리거

            4) 메시지 전송 시 스크롤 트리거
                - sendMessage에서 triggerScrollToBottomRef.current?.() 호출

            5) 새 메시지 수신 시 스크롤 트리거
                - handleNewMessage에서 triggerScrollToBottomRef.current?.() 호출
                - shouldAutoScrollRef로 자동 스크롤 여부 관리

            6) Hook 반환 타입 유지
                - 기존 UseChatRoomReturn 타입 유지 (하위 호환성)
                - 스크롤 관련 함수들은 scrollHook에서 가져와서 반환

            7) roomCreatedAt 추가
                - 채팅방 생성 날짜를 반환 (메시지가 없을 때 표시용)

==============================================

세부요구사항) chatRoom.tsx 리팩토링 구현 상세

            1) 스크롤 관련 로직
                - useChatRoom hook에서 스크롤 관련 함수 및 상태를 받아서 사용
                - 스크롤 트리거 처리 로직은 그대로 유지
                - 스크롤 이벤트 리스너 등록 로직은 그대로 유지

            2) 메시지가 없을 때 UI 개선
                - 채팅방 생성 날짜를 date-divider 스타일로 표시
                - "메시지가 없습니다"를 unread-divider 스타일로 표시
                - formatDateDivider import하여 사용

            3) Import 추가
                - formatDateDivider를 lib/chat/messageFormatter에서 import

==============================================

세부요구사항) Export 업데이트 구현 상세 (index.ts)

            1) useChatRoomScroll export 추가
                - useChatRoomScroll, UseChatRoomScrollProps, UseChatRoomScrollReturn export

==============================================

세부요구사항) 파일 구조 개선

            1) 파일 위치
                - messageFormatter.ts: src/lib/chat/messageFormatter.ts
                - useChatRoomScroll.hook.tsx: src/components/chat/hooks/useChatRoomScroll.hook.tsx

            2) 예상 파일 크기
                - useChatRoom.hook.tsx: ~600-700줄 (리팩토링 후)
                - useChatRoomScroll.hook.tsx: ~200-300줄 (새로 생성)
                - messageFormatter.ts: ~150줄 (새로 생성)

==============================================

세부요구사항) 주의사항

            1) 하위 호환성 유지
                - useChatRoom hook의 반환 타입 및 API 인터페이스 유지
                - 기존 컴포넌트에서 사용하는 방식 그대로 동작

            2) 타입 정의 위치
                - FormattedMessageItem 타입은 useChatRoom.hook.tsx에 유지
                - ChatMessage 타입은 Database 타입에서 import

            3) 스크롤 hook 의존성
                - useChatRoomScroll은 formattedMessages에 의존
                - formattedMessages가 정의된 후에 호출해야 함

            4) 스크롤 트리거 관리
                - shouldAutoScrollRef는 useChatRoom에서 관리
                - 메시지 전송 시 트리거는 메인 hook에서 처리
                - triggerScrollToBottomRef를 사용하여 순환 참조 방지

            5) 초기 로드 플래그
                - isInitialLoadRef는 useChatRoomScroll에서 관리
                - roomId 변경 시 리셋

==============================================

체크리스트) 구현이 완료되면 다음 항목을 포함한 체크리스트를 반환할 것.
            - [ ] 커서룰 @01-common.mdc 적용 결과
            - [ ] 커서룰 @04-func.mdc 적용 결과
            - [ ] lib/chat/messageFormatter.ts 생성 완료 (순수 함수 분리)
            - [ ] useChatRoomScroll.hook.tsx 생성 완료 (스크롤 로직 분리)
            - [ ] useChatRoom.hook.tsx에서 순수 함수 제거 및 import 완료
            - [ ] useChatRoom.hook.tsx에서 스크롤 로직 제거 완료
            - [ ] useChatRoom.hook.tsx에서 useChatRoomScroll hook 통합 완료
            - [ ] useChatRoom.hook.tsx에 roomCreatedAt 추가 완료
            - [ ] chatRoom.tsx에서 formatDateDivider import 완료
            - [ ] chatRoom.tsx에서 메시지 없을 때 UI 개선 완료 (채팅방 생성 날짜, unread-divider 스타일)
            - [ ] index.ts에 useChatRoomScroll export 추가 완료
            - [ ] 기존 API 인터페이스 유지 확인 완료 (하위 호환성)
            - [ ] 파일 구조 개선 확인 완료 (lib/chat/ 패턴)
            - [ ] 코드 가독성 향상 확인 완료
            - [ ] 코드 유지보수성 향상 확인 완료
            - [ ] 모든 린터 에러 해결 완료

==============================================

참고사항) 

            1) 리팩토링 목표:
               - useChatRoom.hook.tsx 코드 길이 감소 (1146줄 → ~600-700줄)
               - 관심사 분리로 가독성 향상
               - 순수 함수 분리로 재사용성 및 테스트 용이성 향상

            2) 프로젝트 구조 일관성:
               - lib/ 폴더에 도메인별 유틸 함수 배치 (avatar/, date/, nickname/, chat/)
               - hooks/ 폴더에 관심사별 hook 분리

            3) 스크롤 로직 분리 이유:
               - 스크롤 관련 로직이 복잡하고 독립적임
               - 별도 hook으로 분리하여 테스트 및 재사용 용이
               - 메인 hook의 복잡도 감소

            4) 순수 함수 분리 이유:
               - 테스트 용이성 향상
               - 재사용성 향상
               - 메인 hook의 복잡도 감소

            5) 하위 호환성 유지:
               - 기존 컴포넌트에서 사용하는 방식 그대로 동작
               - 반환 타입 및 함수 시그니처 유지
               - 내부 구현만 변경

            6) 파일 위치 결정:
               - messageFormatter.ts: lib/chat/ (프로젝트 구조 일관성)
               - useChatRoomScroll.hook.tsx: hooks/ (hook 파일 위치)

            7) 스크롤 hook 통합 방식:
               - useChatRoom 내부에서 useChatRoomScroll 호출
               - scrollHook의 반환값을 useChatRoom의 반환값에 전달
               - 기존 API 인터페이스 유지

            8) 트리거 함수 ref 사용:
               - handleNewMessage와 sendMessage에서 스크롤 트리거
               - formattedMessages가 정의되기 전에 호출될 수 있으므로 ref 사용
               - triggerScrollToBottomRef로 순환 참조 방지

            9) 초기 스크롤 처리:
               - formattedMessages가 준비된 후에만 실행
               - useChatRoomScroll 내부에서 처리
               - isInitialLoadRef로 중복 실행 방지

            10) 메시지 없을 때 UI:
                - 채팅방 생성 날짜를 date-divider 스타일로 표시
                - "메시지가 없습니다"를 unread-divider 스타일로 표시
                - roomCreatedAt을 useChatRoom hook에서 제공

