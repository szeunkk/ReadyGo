아래의 조건을 모두 적용하여, 아래의 요구사항을 모두 구현할 것.
구현 결과를 체크리스트로 반환할 것.

==============================================

조건-커서룰) 아래의 커서룰을 적용하여 작업하고, 이 작업이 끝나면 해당 rules 적용 결과를 체크리스트로 반환할 것.
            - @01-common.mdc
            - @04-func.mdc

==============================================

조건-파일경로) 수정할 TSX 파일경로: src/components/chat/ui/chat-room/chatRoom.tsx
조건-파일경로) 참고할 Hook 파일경로: src/components/chat/hooks/useChatRoom.hook.tsx
조건-파일경로) 참고할 Repository 파일경로: src/repositories/chat.repository.ts
조건-파일경로) 참고할 Auth Provider: src/commons/providers/auth/auth.provider.tsx

==============================================

핵심요구사항) chatRoom.tsx 컴포넌트에서 Mock 데이터를 제거하고, useChatRoom Hook을 사용하여 실제 데이터를 바인딩할 것.

            1) Hook import 및 사용
                - src/components/chat/hooks/index.ts에서 useChatRoom, useChatList Hook을 import할 것.
                - src/commons/providers/auth/auth.provider.tsx에서 useAuth Hook을 import하여 현재 사용자 ID를 가져올 것.
                - roomId prop을 number로 변환하여 useChatRoom Hook에 전달할 것.
                    - roomId는 string 타입 (URL 파라미터)이므로 parseInt(roomId, 10)으로 변환
                    - parseInt 결과가 NaN인 경우 0을 전달 (Hook이 early return하여 빈 메시지 목록 반환)
                    - roomId가 없거나 유효하지 않은 경우 0 전달
                    - 주의: chat_rooms 테이블은 id, type, created_at 필드만 존재 (room_id, room_type, room_name, updated_at 필드 없음)
                    - 라우팅 및 표시 시: String(room.id) 사용 (room.id는 number 타입)
                    - 그룹명은 현재 스키마에 없으므로 기본값 "그룹 채팅" 사용
                - useChatRoom Hook을 호출하여 messages, sendMessage, markAsRead, isLoading, error, isConnected를 받을 것.
                - useChatList Hook을 호출하여 chatRooms를 받을 것 (상대방 정보 조회용).

            2) Mock 데이터 제거
                - MOCK_ROOM_DATA, DEFAULT_MOCK_DATA 객체를 모두 제거할 것.
                - MOCK_CURRENT_USER_ID 상수를 제거할 것.
                - ChatMessage, ChatMessageRead 등의 Mock 타입 정의를 제거할 것.
                - mockChatRooms import를 제거할 것.
                - 주의: chatRoom.tsx에서 mockChatRooms를 import하고 사용 중이므로, mock 제거 시 반드시 함께 수정 필요.
                    - chatRoom.tsx에서 mockChatRooms import 제거
                    - chatRoom.tsx에서 mockChatRooms 사용 부분 제거 또는 대체 (useChatList Hook 사용)
                    - 빌드 에러 방지를 위해 mock 제거와 함께 해당 파일도 반드시 수정할 것.

            3) 메시지 데이터 바인딩
                - useChatRoom Hook이 반환하는 messages 배열을 사용할 것.
                - messages는 Database 타입의 ChatMessage[] 배열임.
                - ChatMessage 타입 구조:
                    - id: number
                    - content: string | null (null일 수 있으므로 null 체크 필요)
                    - content_type: string | null (null일 수 있으므로 null 체크 필요)
                    - created_at: string | null (null일 수 있으므로 null 체크 필요)
                    - sender_id: string | null
                    - room_id: number | null
                    - is_read: boolean | null (Hook에서 기본값 false로 처리)
                
                - groupedMessages 생성 로직은 그대로 유지하되, MOCK_MESSAGES 대신 messages 사용
                - 날짜 구분선, 연속 메시지 로직은 그대로 유지
                - 메시지 필드 null 안전성 처리:
                    - formatMessageTime 호출 전: created_at이 null인 경우 빈 문자열 또는 기본값 사용
                    - formatMessageContent 호출 전: content, content_type이 null인 경우 빈 문자열 또는 기본값 사용
                    - 렌더링 시 null 체크하여 런타임 오류 방지

            4) 현재 사용자 ID 확인
                - src/commons/providers/auth/auth.provider.tsx에서 useAuth() Hook을 import하여 사용할 것.
                - const { user, isSessionSynced } = useAuth();
                - const currentUserId = user?.id;
                - isOwnMessage 판단 시: message.sender_id === currentUserId
                - 주의: 세션 동기화가 완료되지 않은 경우(isSessionSynced === false) user가 null일 수 있으므로, 
                  user를 사용하기 전에 isSessionSynced 확인 또는 옵셔널 체이닝 사용

            5) 상대방 정보 조회
                - useChatList Hook을 추가로 호출하여 chatRooms 목록에서 상대방 정보를 가져올 것.
                - useChatList Hook import 및 호출:
                    - import { useChatList } from '@/components/chat/hooks';
                    - const { chatRooms } = useChatList();
                - chatRooms 배열에서 현재 roomId와 일치하는 채팅방 찾기:
                    - const currentRoom = chatRooms.find(room => room.room.id === roomIdNumber);
                - 해당 채팅방의 otherMember 정보 사용:
                    - otherMember는 user_profiles.Row 타입 (id, nickname, animal_type, avatar_url, status_message 등)
                    - otherMember.id (uuid)는 user_profiles 테이블의 id 필드와 매칭됨
                    - nickname: currentRoom?.otherMember?.nickname ?? "알 수 없음" (null 체크 포함)
                    - animalType: currentRoom?.otherMember?.animal_type (string → AnimalType enum으로 캐스팅 필요)
                    - user_id: currentRoom?.otherMember?.id (user_profiles에는 user_id 필드 없음, id 필드(uuid) 사용)
                    - 아바타 이미지 선택 로직 (공통 유틸리티 함수 사용):
                        - src/lib/avatar/getAvatarImagePath.ts의 getAvatarImagePath 함수를 import하여 사용할 것.
                        - getAvatarImagePath 함수는 항상 string을 반환하며, 기본값은 bear 아바타 (회원가입 시 기본값).
                        - 아바타 이미지 선택 우선순위:
                            1) otherMember?.avatar_url이 null이 아닌 경우: avatar_url 사용 (사용자가 커스텀한 아바타)
                            2) otherMember?.avatar_url이 null인 경우: animal_type을 사용하여 동물 타입 이미지 가져오기
                            3) 둘 다 없으면 기본값 bear 아바타 사용
                        - 사용 예시:
                            import { getAvatarImagePath } from '@/lib/avatar/getAvatarImagePath';
                            const avatarImagePath = getAvatarImagePath(
                              otherMember?.avatar_url,
                              otherMember?.animal_type
                            );
                    - 주의: user_profiles에 status 필드는 없으므로, Avatar status는 'offline' 기본값 사용
                - otherMember가 없는 경우 기본값 사용:
                    - nickname: "알 수 없음"
                    - animalType: undefined
                    - Avatar status: 'offline' (user_profiles 스키마에 status 필드 없음)
                    - 아바타 이미지: 기본값 사용 또는 undefined
                - 장점: 이미 로드된 데이터 재사용, 추가 API 호출 불필요
                - 주의: chatRooms가 아직 로드되지 않은 경우 otherMember가 undefined일 수 있으므로 옵셔널 체이닝 사용

            6) 메시지 전송 기능
                - Input 컴포넌트에 상태 관리 추가:
                    - const [messageInput, setMessageInput] = useState('');
                - Input의 value와 onChange 연결
                - 전송 버튼 클릭 시:
                    - sendMessage(messageInput, 'text') 호출
                    - 전송 성공 시 messageInput 초기화
                    - 전송 실패 시 에러 처리 (에러 메시지 표시 또는 콘솔 로그)
                - Enter 키 입력 시 전송 (선택사항)
                - 차단 상태인 경우 전송 비활성화 (기존 로직 유지)

            7) 읽음 상태 처리
                - useChatRoom Hook이 자동으로 읽음 처리를 수행하므로, 컴포넌트에서는 추가 로직 불필요
                - is_read 필드는 chat_messages 테이블에서 boolean | null 타입
                - Hook에서 is_read가 null인 경우 기본값 false로 처리하므로, 컴포넌트에서는 messages의 is_read 필드를 그대로 사용
                - 읽음 표시는 기존 로직 유지 (MOCK_MESSAGE_READS 대신 messages의 is_read 필드 사용)
                - 주의: is_read가 null이면 false로 가정하여 처리

            8) 차단 상태 처리
                - 현재 Hook에서 차단 상태를 제공하지 않으므로, 별도 API 호출 필요
                - 임시 처리: 기본값 false 사용
                - 추후 API 구현 시 차단 상태를 동적으로 조회하여 표시
                - 차단 배너는 isBlocked 상태에 따라 표시 (기존 로직 유지)

            9) 로딩 상태 처리
                - isLoading이 true인 경우 로딩 UI 표시 (선택사항: 스켈레톤 또는 로딩 메시지)
                - 메시지 리스트 영역에 로딩 표시

            10) 에러 상태 처리
                - error가 null이 아닌 경우 에러 메시지 표시 (선택사항: UI 표시 또는 콘솔 로그)
                - 에러 발생 시에도 기존 UI는 유지하여 앱이 중단되지 않도록 처리

            11) 연결 상태 처리 (선택사항)
                - isConnected 상태를 활용하여 연결 상태 표시 (선택사항)

==============================================

세부요구사항) 메시지 전송 구현 상세

            1) Input 상태 관리
                - useState를 사용하여 messageInput 상태 관리
                - Input 컴포넌트에 value={messageInput}, onChange={(e) => setMessageInput(e.target.value)} 연결

            2) 전송 버튼 클릭 핸들러
                - handleSendMessage 함수 작성:
                    - messageInput이 비어있으면 전송하지 않음
                    - sendMessage(messageInput, 'text') 호출
                    - try-catch로 에러 처리
                    - 전송 성공 시 setMessageInput('')로 초기화
                    - 전송 실패 시 에러 메시지 표시 (선택사항)

            3) Enter 키 입력 처리 (선택사항)
                - Input 컴포넌트에 onKeyDown 핸들러 추가
                - Enter 키 입력 시 handleSendMessage 호출
                - Shift+Enter는 줄바꿈으로 처리 (선택사항)

            4) 전송 중 상태 처리
                - 전송 중에는 버튼 비활성화 (선택사항)
                - useState로 isSending 상태 관리

==============================================

세부요구사항) 상대방 정보 조회

            1) useChatList Hook 활용 (권장 방법)
                - useChatList Hook을 추가로 호출:
                    - import { useChatList } from '@/components/chat/hooks';
                    - const { chatRooms } = useChatList();
                - chatRooms 배열에서 현재 roomId와 일치하는 채팅방 찾기:
                    - const roomIdNumber = parseInt(roomId, 10);
                    - const currentRoom = chatRooms.find(room => room.room.id === roomIdNumber);
                - otherMember 정보 추출:
                    - const otherMember = currentRoom?.otherMember;
                    - nickname: otherMember?.nickname ?? "알 수 없음" (null 체크 포함)
                    - animalType: otherMember?.animal_type (string → AnimalType enum으로 캐스팅 필요)
                    - user_id: otherMember?.id (user_profiles에는 user_id 필드 없음, id 필드 사용)
                    - 주의: user_profiles 스키마에는 status 필드가 없으므로, Avatar status는 'offline' 기본값 사용
                - 옵셔널 체이닝 사용하여 안전하게 접근
                - chatRooms가 아직 로드되지 않은 경우 기본값 사용
                - 장점: 이미 로드된 데이터 재사용, 추가 API 호출 불필요, 성능 최적화
                - 주의: chatRooms가 빈 배열이거나 해당 roomId가 없는 경우 처리 필요

            2) 기본값 처리
                - otherMember가 없는 경우 기본값 사용:
                    - nickname: "알 수 없음"
                    - animalType: undefined
                    - status: 'offline'
                - useMemo를 사용하여 roomId 변경 시 상대방 정보 재계산

==============================================

세부요구사항) 컴포넌트 구조 유지

            1) 기존 UI 구조 유지
                - 헤더, 메시지 리스트, 입력 영역 구조는 그대로 유지
                - 스타일링은 변경하지 않음
                - 접근성 속성(aria-label 등)은 그대로 유지

            2) 함수 유지 및 수정
                - formatMessageTime 함수는 그대로 유지 (단, created_at이 null인 경우 처리 추가)
                - formatDateDivider 함수는 그대로 유지
                - isNewDate 함수는 그대로 유지
                - isConsecutiveMessage 함수는 그대로 유지
                - formatMessageContent 함수는 content, content_type이 null인 경우 처리 추가

            3) 상태 관리
                - useSideProfilePanel Hook은 그대로 유지
                - messageInput 상태 추가
                - isSending 상태 추가 (선택사항)

==============================================

세부요구사항) 에러 처리 및 예외 상황

            1) roomId 없음 또는 유효하지 않음
                - roomId가 없거나 NaN인 경우:
                    - parseInt(roomId, 10) 결과가 NaN이면 0으로 변환
                    - useChatRoom Hook에 0 전달 시 Hook이 early return하여 빈 메시지 목록 반환
                    - UI 처리: ChatNull 컴포넌트 표시 또는 빈 상태 UI 표시
                    - 예시: const roomIdNumber = isNaN(parseInt(roomId, 10)) ? 0 : parseInt(roomId, 10);

            2) 사용자 인증 없음
                - user가 null인 경우: 로그인 페이지로 리다이렉트 또는 에러 메시지
                - user?.id가 없는 경우: 로그인 페이지로 리다이렉트 또는 에러 메시지
                - isSessionSynced가 false인 경우: 세션 동기화가 완료될 때까지 대기하거나 기본값 사용
                - useAuth Hook이 null을 반환하는 경우 처리

            3) 메시지 없음
                - messages.length === 0인 경우: 빈 메시지 UI 표시 (기존 로직 유지)

            8) 메시지 필드 null 처리
                - content가 null인 경우: formatMessageContent에서 빈 문자열 또는 기본 텍스트 반환
                - content_type이 null인 경우: formatMessageContent에서 기본값 'text' 사용
                - created_at이 null인 경우: formatMessageTime에서 빈 문자열 또는 기본값 반환
                - 포맷 함수 호출 전 null 체크하여 런타임 오류 방지

            4) 로딩 중
                - isLoading === true인 경우: 로딩 UI 표시 (선택사항)

            5) 에러 발생
                - error가 null이 아닌 경우: 콘솔 에러 로그 출력
                - 사용자에게는 기존 UI 유지 (에러 메시지 UI는 선택사항)

            6) 전송 실패
                - sendMessage 호출 실패 시: 에러 메시지 표시 또는 토스트 알림
                - messageInput은 그대로 유지하여 재전송 가능하도록 처리

            7) 상대방 정보 없음
                - otherMember가 없는 경우: 기본값 사용 ("알 수 없음")
                - Avatar 컴포넌트에 전달할 정보:
                    - animalType: undefined (아바타 이미지는 기본값 사용)
                    - status: 'offline' (user_profiles 스키마에 status 필드 없음)
                    - nickname: "알 수 없음"
                - 아바타 이미지 선택: otherMember가 없으므로 getAvatarImagePath(null, null)을 호출하면 기본값 bear 아바타 반환

==============================================

체크리스트) 구현이 완료되면 다음 항목을 포함한 체크리스트를 반환할 것.
            - [ ] 커서룰 @01-common.mdc 적용 결과
            - [ ] 커서룰 @04-func.mdc 적용 결과
            - [ ] useChatRoom Hook import 및 사용 완료
            - [ ] useChatList Hook import 및 사용 완료 (상대방 정보 조회용)
            - [ ] useAuth Hook import 및 사용 완료
            - [ ] roomId string → number 변환 완료 (NaN 처리 포함)
            - [ ] roomId가 0인 경우 UI 처리 완료 (ChatNull 또는 빈 상태)
            - [ ] 메시지 필드 null 안전성 처리 완료
            - [ ] otherMember 스키마 정정 완료 (user_id → id, status 필드 제거)
            - [ ] Mock 데이터 및 타입 정의 제거 완료
            - [ ] messages 배열 바인딩 완료
            - [ ] 현재 사용자 ID로 isOwnMessage 판단 완료
            - [ ] 메시지 전송 기능 구현 완료 (Input 상태, 전송 버튼, 에러 처리)
            - [ ] 상대방 정보 조회 (임시 처리 또는 API 호출) 완료
            - [ ] 차단 상태 처리 (임시 처리 또는 API 호출) 완료
            - [ ] 로딩 상태 처리 완료
            - [ ] 에러 상태 처리 완료
            - [ ] 기존 UI 구조 및 스타일 유지 완료
            - [ ] 접근성 속성 유지 완료
            - [ ] 날짜 구분선, 연속 메시지 로직 유지 완료

==============================================

참고사항) 

            1) useChatRoom Hook은 이미 다음 기능을 자동으로 처리함:
                - 초기 메시지 로드 (API 호출)
                - postgres_changes 구독 (실시간 메시지 수신)
                - useRealtimeChat 통합 (Broadcast 기반 실시간 전송)
                - 읽음 처리 (roomId 변경 시 자동)
                - 중복 메시지 방지

            2) 메시지 전송 플로우:
                - sendMessage 호출 → API로 DB 저장 → Broadcast로 실시간 전송
                - postgres_changes로 INSERT 이벤트 수신 → messages 배열에 자동 추가
                - 중복 방지를 위해 seenMessageIdsRef로 관리

            3) 상대방 정보 및 차단 상태는 현재 Hook에서 제공하지 않으므로,
               추후 API 확장 시 동적으로 조회하여 표시할 수 있도록 구조만 유지.

            4) useChatList Hook을 사용하여 상대방 정보를 가져오는 것이 권장 방법임.
               이미 로드된 chatRooms 데이터를 재사용하므로 추가 API 호출이 불필요하고 성능상 이점이 있음.

            5) 읽음 상태(is_read)는 chat_messages 테이블에서 boolean | null 타입임.
               useChatRoom Hook에서 is_read가 null인 경우 기본값 false로 처리하므로,
               컴포넌트에서는 messages의 is_read 필드를 그대로 사용하면 됨 (없으면 false로 가정).

            6) 아바타 이미지 선택 로직:
               - 공통 유틸리티 함수 사용: src/lib/avatar/getAvatarImagePath.ts
               - getAvatarImagePath 함수를 import하여 사용할 것.
               - 함수는 항상 string을 반환하며, 기본값은 bear 아바타 (회원가입 시 기본값).
               - 선택 우선순위:
                 1) otherMember?.avatar_url이 null이 아닌 경우: avatar_url 사용 (사용자가 커스텀한 아바타)
                 2) otherMember?.avatar_url이 null인 경우: animal_type을 사용하여 동물 타입 이미지 가져오기
                 3) 둘 다 없으면 기본값 bear 아바타 사용
               - 사용 예시:
                 import { getAvatarImagePath } from '@/lib/avatar/getAvatarImagePath';
                 const avatarImagePath = getAvatarImagePath(
                   otherMember?.avatar_url,
                   otherMember?.animal_type
                 );
               - 주의: otherMember.id (uuid)는 user_profiles 테이블의 id 필드와 매칭됨.
                 다른 페이지에서도 동일한 유틸리티 함수를 사용하여 user_profiles 데이터로 아바타 이미지를 가져올 수 있음.

            7) DB 스키마 정리:
               - chat_rooms 테이블: id (number), type (string | null), created_at (string | null)만 존재
               - room_id, room_type, room_name, updated_at 필드는 없음
               - user_profiles 테이블: id (string), nickname (string | null), animal_type (string), avatar_url (string | null) 등
               - user_profiles에 user_id, status 필드는 없음 (id 필드가 user_id 역할, status는 presence store에서 조회)
               - chat_messages 테이블: content, content_type, created_at이 모두 nullable

            7) 인증 방식
                - 클라이언트 사이드: useAuth() Hook 사용 (src/commons/providers/auth/auth.provider.tsx)
                - useAuth()는 /api/auth/session API를 통해 세션을 조회함
                - user?.id로 현재 사용자 ID를 가져올 수 있음
                - 세션 동기화 완료 여부는 isSessionSynced로 확인 가능 (선택사항)
                - user가 null이거나 user?.id가 없는 경우 인증되지 않은 상태로 처리
                - 서버 사이드 인증은 API 라우트에서 createAuthenticatedClient 함수를 통해 처리되므로,
                  컴포넌트에서는 useAuth() Hook만 사용하면 됨


