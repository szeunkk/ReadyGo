아래의 조건을 모두 적용하여, 아래의 요구사항을 모두 구현할 것.
구현 결과를 체크리스트로 반환할 것.

==============================================

조건-커서룰) 아래의 커서룰을 적용하여 작업하고, 이 작업이 끝나면 해당 rules 적용 결과를 체크리스트로 반환할 것.
            - @01-common.mdc
            - @04-func.mdc

==============================================

조건-파일경로) 참고할 API 라우트 파일경로: src/app/api/chat/message/route.ts
조건-파일경로) 구현될 API 라우트 파일경로: src/app/api/party/[id]/messages/route.ts

==============================================

핵심요구사항) GET, POST /api/party/[id]/messages API를 구현할 것.

            ==============================================
            1) GET: 메시지 조회
            ==============================================
            1-1) 인증/권한 조건
                1-1-1) 인증 확인
                    - Supabase SSR 클라이언트를 사용하여 인증을 처리한다.
                    - SSR 클라이언트는 쿠키에서 세션을 자동으로 읽고, 토큰 갱신도 자동으로 처리한다.
                    - supabase.auth.getUser()를 통해 사용자 정보를 확인할 것.
                    - 사용자 정보가 없는 경우: { message: 'Unauthorized', detail: 'Authentication required' }, status: 401 반환

                1-1-2) 권한 확인
                    - 파티 멤버(party_members) 또는 파티 작성자(creator_id)만 메시지를 조회할 수 있다.
                    - 권한 확인은 Service 레이어에서 처리하지 않고, API 레이어에서 직접 확인할 것.
                    - 권한이 없는 경우: { error: '파티 멤버만 메시지를 조회할 수 있습니다.' }, status: 403 반환

            1-2) API 구현 방법
                1-2-1) GET 메서드 추가
                    - 구현 위치: src/app/api/party/[id]/messages/route.ts
                    - export const GET = async (request: NextRequest, { params }: { params: { id: string } }) => { ... } 형식으로 구현할 것.

                1-2-2) Supabase SSR 클라이언트 생성
                    - import { createClient } from '@/lib/supabase/server' 사용
                    - SSR 클라이언트는 쿠키에서 세션을 자동으로 읽고, 토큰 갱신도 자동으로 처리한다.
                    - const supabase = createClient() 형식으로 생성할 것.
                    - 별도의 쿠키 읽기나 Authorization 헤더 설정이 필요하지 않다.

                1-2-3) 파라미터 검증
                    - params.id를 parseInt(params.id, 10)로 변환할 것.
                    - NaN인 경우: { code: 'CHAT_VALIDATION_ERROR', message: '유효하지 않은 파티 ID입니다.' }, status: 400 반환

                1-2-4) 쿼리 파라미터 파싱
                    - limit: 기본값 50, 선택적 파라미터
                    - offset: 기본값 0, 선택적 파라미터
                    - URL의 searchParams에서 추출할 것.
                    - limit과 offset은 parseInt로 변환하고, 유효하지 않은 경우 기본값 사용.
                    - limit 유효성 검증: 최소 1, 최대 100으로 제한. 범위를 벗어나는 경우 기본값 50 사용.
                    - offset 유효성 검증: 최소 0. 음수인 경우 0으로 설정.

                1-2-5) 파티 존재 확인
                    - party_posts 테이블에서 해당 파티가 존재하는지 확인할 것.
                    - 주의: 존재 확인용으로는 id와 creator_id 컬럼만 select할 것. (다른 컬럼명은 스키마에 따라 다를 수 있음)
                    - supabase.from('party_posts').select('id, creator_id').eq('id', postId).single() 사용
                    - 파티가 존재하지 않는 경우: fetchError 객체의 code 속성이 'PGRST116'인지 확인하여 처리.
                    - if (fetchError && fetchError.code === 'PGRST116') 조건으로 확인할 것.
                    - 파티가 존재하지 않는 경우: { error: '파티를 찾을 수 없습니다.' }, status: 404 반환
                    - 기타 조회 에러: { error: fetchError.message }, status: 500 반환
                    - 중요: RLS 정책 확인 필요
                        - party_posts 테이블의 RLS 정책이 "로그인 유저는 id/creator_id 정도는 조회 가능" 또는 "로그인 유저 + 필요한 조건"으로 설정되어 있어야 함.
                        - 권한 확인 로직을 실행하기 전에 파티 존재 확인 쿼리가 실행되므로, RLS 정책이 이를 허용해야 함.
                        - RLS 정책이 없거나 너무 제한적이면 권한 확인 전에 쿼리 자체가 막힐 수 있음.

                1-2-6) 권한 확인
                    - partyData.creator_id와 user.id를 비교하여 작성자인지 확인.
                    - 작성자가 아닌 경우, party_members 테이블에서 해당 사용자가 멤버인지 확인.
                    - supabase.from('party_members').select('id').eq('post_id', postId).eq('user_id', user.id).single() 사용
                    - 작성자도 아니고 멤버도 아닌 경우: { error: '파티 멤버만 메시지를 조회할 수 있습니다.' }, status: 403 반환
                    - 중요: RLS 정책 확인 필요
                        - party_members 테이블의 RLS 정책이 "로그인 유저가 본인 row 조회 가능" 또는 "파티 작성자/멤버가 멤버십 확인 가능"으로 설정되어 있어야 함.
                        - 권한 확인을 위해 party_members 조회가 필요하므로, RLS 정책이 이를 허용해야 함.
                        - RLS 정책이 없거나 너무 제한적이면 권한 확인 쿼리 자체가 막힐 수 있음.

                1-2-7) Service 호출
                    - import { getPartyMessagesService } from '@/services/party/getPartyMessagesService' 사용
                    - getPartyMessagesService(postId, limit, offset) 호출할 것.
                    - Service는 입력 검증과 Repository 에러 처리를 담당한다.

                1-2-8) 성공 응답
                    - 성공 시: { data: messages }, status: 200 반환

            ==============================================
            2) POST: 메시지 전송
            ==============================================
            2-1) 인증/권한 조건
                2-1-1) 인증 확인
                    - Supabase SSR 클라이언트를 사용하여 인증을 처리한다.
                    - SSR 클라이언트는 쿠키에서 세션을 자동으로 읽고, 토큰 갱신도 자동으로 처리한다.
                    - supabase.auth.getUser()를 통해 사용자 정보를 확인할 것.
                    - 사용자 정보가 없는 경우: { message: 'Unauthorized', detail: 'Authentication required' }, status: 401 반환

                2-1-2) 권한 확인
                    - 파티 멤버(party_members) 또는 파티 작성자(creator_id)만 메시지를 전송할 수 있다.
                    - 권한 확인은 Service 레이어에서 처리하지 않고, API 레이어에서 직접 확인할 것.
                    - 권한이 없는 경우: { error: '파티 멤버만 메시지를 전송할 수 있습니다.' }, status: 403 반환

            2-2) API 구현 방법
                2-2-1) POST 메서드 추가
                    - 구현 위치: src/app/api/party/[id]/messages/route.ts
                    - GET 메서드와 동일한 파일에 POST 메서드를 추가할 것.
                    - export const POST = async (request: NextRequest, { params }: { params: { id: string } }) => { ... } 형식으로 구현할 것.

                2-2-2) Supabase SSR 클라이언트 생성
                    - import { createClient } from '@/lib/supabase/server' 사용
                    - SSR 클라이언트는 쿠키에서 세션을 자동으로 읽고, 토큰 갱신도 자동으로 처리한다.
                    - const supabase = createClient() 형식으로 생성할 것.
                    - 별도의 쿠키 읽기나 Authorization 헤더 설정이 필요하지 않다.

                2-2-3) 파라미터 검증
                    - params.id를 parseInt(params.id, 10)로 변환할 것.
                    - NaN인 경우: { code: 'CHAT_VALIDATION_ERROR', message: '유효하지 않은 파티 ID입니다.' }, status: 400 반환

                2-2-4) 요청 본문 파싱
                    - request.json()을 통해 본문을 파싱할 것.
                    - JSON 파싱 실패 시 (잘못된 JSON 형식): { code: 'CHAT_VALIDATION_ERROR', message: '요청 본문이 올바르지 않습니다.' }, status: 400 반환
                    - content: 필수, 문자열
                    - content가 없거나 빈 문자열인 경우: Service에서 검증하지만, API에서도 기본 검증 가능.

                2-2-5) 파티 존재 확인
                    - party_posts 테이블에서 해당 파티가 존재하는지 확인할 것.
                    - 주의: 존재 확인용으로는 id와 creator_id 컬럼만 select할 것. (다른 컬럼명은 스키마에 따라 다를 수 있음)
                    - supabase.from('party_posts').select('id, creator_id').eq('id', postId).single() 사용
                    - 파티가 존재하지 않는 경우: fetchError 객체의 code 속성이 'PGRST116'인지 확인하여 처리.
                    - if (fetchError && fetchError.code === 'PGRST116') 조건으로 확인할 것.
                    - 파티가 존재하지 않는 경우: { error: '파티를 찾을 수 없습니다.' }, status: 404 반환
                    - 기타 조회 에러: { error: fetchError.message }, status: 500 반환
                    - 중요: RLS 정책 확인 필요
                        - party_posts 테이블의 RLS 정책이 "로그인 유저는 id/creator_id 정도는 조회 가능" 또는 "로그인 유저 + 필요한 조건"으로 설정되어 있어야 함.
                        - 권한 확인 로직을 실행하기 전에 파티 존재 확인 쿼리가 실행되므로, RLS 정책이 이를 허용해야 함.
                        - RLS 정책이 없거나 너무 제한적이면 권한 확인 전에 쿼리 자체가 막힐 수 있음.

                2-2-6) 권한 확인
                    - partyData.creator_id와 user.id를 비교하여 작성자인지 확인.
                    - 작성자가 아닌 경우, party_members 테이블에서 해당 사용자가 멤버인지 확인.
                    - supabase.from('party_members').select('id').eq('post_id', postId).eq('user_id', user.id).single() 사용
                    - 작성자도 아니고 멤버도 아닌 경우: { error: '파티 멤버만 메시지를 전송할 수 있습니다.' }, status: 403 반환
                    - 중요: RLS 정책 확인 필요
                        - party_members 테이블의 RLS 정책이 "로그인 유저가 본인 row 조회 가능" 또는 "파티 작성자/멤버가 멤버십 확인 가능"으로 설정되어 있어야 함.
                        - 권한 확인을 위해 party_members 조회가 필요하므로, RLS 정책이 이를 허용해야 함.
                        - RLS 정책이 없거나 너무 제한적이면 권한 확인 쿼리 자체가 막힐 수 있음.

                2-2-7) Service 호출
                    - import { sendPartyMessageService } from '@/services/party/sendPartyMessageService' 사용
                    - sendPartyMessageService(postId, user.id, content) 호출할 것.
                    - Service는 입력 검증과 Repository 에러 처리를 담당한다.

                2-2-8) 성공 응답
                    - 성공 시: { data: savedMessage }, status: 201 반환

            ==============================================
            3) 에러 처리
            ==============================================
            3-1) 인증 에러
                - 사용자 정보가 없는 경우: 401 상태 코드 반환
                - SSR 클라이언트는 쿠키에서 세션을 자동으로 읽으므로, 별도의 토큰 확인이 필요하지 않다.

            3-2) 파라미터 에러
                - 유효하지 않은 파티 ID: 400 상태 코드 반환
                - limit/offset 범위를 벗어나는 경우: 기본값으로 처리 (400 에러 반환하지 않음)
                - JSON 파싱 실패 (잘못된 요청 본문): 400 상태 코드 반환
                - Service의 ChatValidationError: 400 상태 코드 반환

            3-3) 권한 에러
                - 파티 멤버가 아닌 경우: 403 상태 코드 반환

            3-4) 데이터 에러
                - 파티가 존재하지 않는 경우: fetchError.code === 'PGRST116' 조건으로 확인하여 404 상태 코드 반환
                - 데이터베이스 조회/생성 에러: 500 상태 코드 반환
                - Service의 ChatFetchError: 500 상태 코드 반환
                - Service의 ChatCreateError: 500 상태 코드 반환

            3-5) 예외 처리
                - try-catch 블록으로 전체 로직을 감싸서 예상치 못한 에러를 처리할 것.
                - 예외 발생 시: { code: 'INTERNAL_ERROR', message: error instanceof Error ? error.message : 'Unknown error' }, status: 500 반환

            ==============================================
            4) 테스트 검증 포인트
            ==============================================
            4-1) GET 성공 시나리오
                - 인증된 파티 멤버가 메시지 조회 성공
                - 응답: { data: messages }, status: 200
                - limit과 offset 파라미터가 올바르게 적용되는지 확인

            4-2) GET 실패 시나리오
                - 인증되지 않은 사용자 (쿠키에 세션이 없는 경우): 401 에러 반환
                - 유효하지 않은 파티 ID: 400 에러 반환
                - 존재하지 않는 파티 (fetchError.code === 'PGRST116'): 404 에러 반환
                - 파티 멤버가 아닌 사용자: 403 에러 반환
                - RLS 정책으로 인한 쿼리 실패: 권한 확인 전에 쿼리가 막힐 수 있음 (RLS 정책 확인 필요)

            4-3) POST 성공 시나리오
                - 인증된 파티 멤버가 메시지 전송 성공
                - 응답: { data: savedMessage }, status: 201
                - party_messages 테이블에 레코드가 생성되었는지 확인

            4-4) POST 실패 시나리오
                - 인증되지 않은 사용자 (쿠키에 세션이 없는 경우): 401 에러 반환
                - 유효하지 않은 파티 ID: 400 에러 반환
                - 존재하지 않는 파티 (fetchError.code === 'PGRST116'): 404 에러 반환
                - 파티 멤버가 아닌 사용자: 403 에러 반환
                - JSON 파싱 실패 (잘못된 요청 본문): 400 에러 반환
                - content가 없는 경우: 400 에러 반환 (Service에서 검증)
                - RLS 정책으로 인한 쿼리 실패: 권한 확인 전에 쿼리가 막힐 수 있음 (RLS 정책 확인 필요)

            4-5) 데이터 검증
                - party_posts 테이블의 실제 데이터 사용
                - party_members 테이블의 실제 데이터 사용
                - party_messages 테이블의 실제 데이터 사용

            ==============================================
            5) 구현 참고사항
            ==============================================
            5-1) 기존 API 참고
                - src/app/api/chat/message/route.ts의 GET, POST 메서드를 참고하여 동일한 스타일로 구현할 것.
                - Service 에러 매핑 방식을 동일하게 사용할 것.
                - ChatValidationError → 400
                - ChatFetchError → 500
                - ChatCreateError → 500

            5-2) 코드 구조
                - 주석을 적절히 추가하여 각 단계를 명확히 구분할 것.
                - 에러 메시지는 한글로 작성할 것.
                - HTTP 상태 코드는 RESTful API 표준을 따를 것.
                - export const dynamic = 'force-dynamic' 추가할 것.

            5-3) 데이터베이스 스키마
                - party_posts 테이블: id (bigint, PK), creator_id (uuid)
                    - 주의: 존재 확인용으로는 id와 creator_id만 사용할 것. 다른 컬럼명은 스키마에 따라 다를 수 있음.
                - party_members 테이블: post_id (bigint), user_id (uuid), role (text), joined_at (timestamptz)
                - party_messages 테이블: id (bigint, PK), post_id (bigint), sender_id (uuid), content (text), created_at (timestamptz)

            5-5) RLS 정책 사전 확인 (중요)
                - 구현 전에 다음 RLS 정책이 설정되어 있는지 확인할 것:
                    - party_posts: 로그인 유저는 id/creator_id 조회 가능 (또는 로그인 유저 + 필요한 조건)
                    - party_members: 로그인 유저가 본인 row 조회 가능 (또는 파티 작성자/멤버가 멤버십 확인 가능)
                - RLS 정책이 없거나 너무 제한적이면 권한 확인 로직 실행 전에 쿼리 자체가 막힐 수 있음.
                - 이는 구현 코드 문제가 아니라 요구사항과 DB 정책의 충돌이므로, 프롬프트 단계에서 명시하여 팀 작업이 매끄럽게 진행되도록 할 것.

            5-4) Service 사용
                - getPartyMessagesService: 메시지 조회 Service
                - sendPartyMessageService: 메시지 전송 Service
                - Service는 입력 검증과 Repository 에러 처리를 담당하므로, API 레이어에서는 Service 에러를 HTTP 상태 코드로 매핑하는 것에 집중할 것.
